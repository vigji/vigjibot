Directory Structure:

└── ./
    ├── src
    │   ├── app
    │   │   ├── (nav)
    │   │   │   ├── about
    │   │   │   │   └── page.tsx
    │   │   │   ├── dashboards
    │   │   │   │   ├── view
    │   │   │   │   │   └── [id]
    │   │   │   │   │       └── page.tsx
    │   │   │   │   └── page.tsx
    │   │   │   ├── questions
    │   │   │   │   └── [id]
    │   │   │   │       ├── EmbedSection.tsx
    │   │   │   │       ├── layout.tsx
    │   │   │   │       ├── loading.tsx
    │   │   │   │       ├── page.tsx
    │   │   │   │       └── Section.tsx
    │   │   │   ├── status
    │   │   │   │   └── page.tsx
    │   │   │   ├── tools
    │   │   │   │   └── page.tsx
    │   │   │   ├── common.ts
    │   │   │   ├── hooks.ts
    │   │   │   ├── layout.tsx
    │   │   │   ├── NavMenu.tsx
    │   │   │   ├── page.tsx
    │   │   │   ├── QueryForm.tsx
    │   │   │   ├── QuestionCardsList.tsx
    │   │   │   ├── SearchForm.tsx
    │   │   │   ├── SearchScreen.tsx
    │   │   │   ├── SearchUIProvider.tsx
    │   │   │   └── ShowMore.tsx
    │   │   ├── (raw)
    │   │   │   ├── dashboards
    │   │   │   │   └── embed
    │   │   │   │       └── [id]
    │   │   │   │           └── page.tsx
    │   │   │   ├── questions
    │   │   │   │   └── embed
    │   │   │   │       └── [id]
    │   │   │   │           └── page.tsx
    │   │   │   ├── recursion
    │   │   │   │   └── page.tsx
    │   │   │   └── secretEmbed
    │   │   │       └── page.tsx
    │   │   ├── api
    │   │   │   └── graphql
    │   │   │       └── route.ts
    │   │   ├── layout.tsx
    │   │   └── Root.tsx
    │   ├── backend
    │   │   ├── cli
    │   │   │   ├── commands
    │   │   │   │   ├── all.ts
    │   │   │   │   ├── elastic.ts
    │   │   │   │   ├── frontpage.ts
    │   │   │   │   ├── platform-commands.ts
    │   │   │   │   └── shell.ts
    │   │   │   ├── index.ts
    │   │   │   └── utils.ts
    │   │   ├── manual
    │   │   │   └── count-uniq-history-entries.ts
    │   │   ├── platforms
    │   │   │   ├── manifold
    │   │   │   │   ├── api.ts
    │   │   │   │   ├── apiSchema.ts
    │   │   │   │   ├── extendedTables.ts
    │   │   │   │   ├── fetch.ts
    │   │   │   │   ├── fetchAndStore.ts
    │   │   │   │   ├── index.ts
    │   │   │   │   └── marketsToQuestions.ts
    │   │   │   ├── metaculus
    │   │   │   │   ├── api.ts
    │   │   │   │   ├── api2.ts
    │   │   │   │   └── index.ts
    │   │   │   ├── polymarket
    │   │   │   │   ├── gamma.ts
    │   │   │   │   └── index.ts
    │   │   │   ├── _example.ts
    │   │   │   ├── betfair.ts
    │   │   │   ├── fantasyscotus.ts
    │   │   │   ├── foretold.ts
    │   │   │   ├── givewellopenphil.ts
    │   │   │   ├── goodjudgment.ts
    │   │   │   ├── goodjudgmentopen.ts
    │   │   │   ├── guesstimate.ts
    │   │   │   ├── infer.ts
    │   │   │   ├── insight.ts
    │   │   │   ├── kalshi.ts
    │   │   │   ├── predictit.ts
    │   │   │   ├── rootclaim.ts
    │   │   │   ├── smarkets.ts
    │   │   │   ├── wildeford.ts
    │   │   │   └── xrisk.ts
    │   │   ├── utils
    │   │   │   ├── misc
    │   │   │   │   ├── process-forecasts-into-elicit.ts
    │   │   │   │   ├── process-forecasts-template.ts
    │   │   │   │   └── test.ts
    │   │   │   ├── elastic.ts
    │   │   │   ├── fetchUtils.ts
    │   │   │   ├── getSecrets.ts
    │   │   │   ├── hash.ts
    │   │   │   ├── measureTime.ts
    │   │   │   ├── sleep.ts
    │   │   │   └── toMarkdown.ts
    │   │   ├── dbUtils.ts
    │   │   ├── frontpage.ts
    │   │   ├── platformRegistry.ts
    │   │   ├── platformUtils.ts
    │   │   └── types.ts
    │   ├── common
    │   │   └── types.ts
    │   ├── graphql
    │   │   ├── schema
    │   │   │   ├── dashboards.ts
    │   │   │   ├── frontpage.ts
    │   │   │   ├── index.ts
    │   │   │   ├── platforms.ts
    │   │   │   ├── questions.ts
    │   │   │   └── search.ts
    │   │   ├── builder.ts
    │   │   └── print-schema.ts
    │   ├── styles
    │   │   └── main.css
    │   ├── web
    │   │   ├── common
    │   │   │   ├── BoxedLink.tsx
    │   │   │   ├── Button.tsx
    │   │   │   ├── Card.tsx
    │   │   │   ├── Collapsible.tsx
    │   │   │   ├── CopyParagraph.tsx
    │   │   │   ├── CopyText.tsx
    │   │   │   ├── ErrorBoundary.tsx
    │   │   │   ├── InfoBox.tsx
    │   │   │   ├── LineHeader.tsx
    │   │   │   ├── MultiSelectPlatform.tsx
    │   │   │   └── Spinner.tsx
    │   │   ├── display
    │   │   │   ├── ButtonsForStars.tsx
    │   │   │   ├── DashboardCreator.tsx
    │   │   │   └── SliderElement.tsx
    │   │   ├── icons
    │   │   │   ├── Favicon.tsx
    │   │   │   ├── index.ts
    │   │   │   ├── Logo.tsx
    │   │   │   └── Logo2.tsx
    │   │   ├── questions
    │   │   │   ├── components
    │   │   │   │   ├── HistoryChart
    │   │   │   │   │   ├── index.tsx
    │   │   │   │   │   ├── InnerChart.tsx
    │   │   │   │   │   ├── InnerChartPlaceholder.tsx
    │   │   │   │   │   ├── Legend.tsx
    │   │   │   │   │   └── utils.ts
    │   │   │   │   ├── QuestionCard
    │   │   │   │   │   ├── index.tsx
    │   │   │   │   │   └── QuestionFooter.tsx
    │   │   │   │   ├── CaptureQuestion.tsx
    │   │   │   │   ├── IndicatorsTable.tsx
    │   │   │   │   ├── PlatformLink.tsx
    │   │   │   │   ├── QuestionChartOrVisualization.tsx
    │   │   │   │   ├── QuestionInfoRow.tsx
    │   │   │   │   ├── QuestionOptions.tsx
    │   │   │   │   ├── QuestionTitle.tsx
    │   │   │   │   └── Stars.tsx
    │   │   │   └── utils.ts
    │   │   ├── worker
    │   │   │   ├── searchWithElastic.ts
    │   │   │   └── uploadToImgur.ts
    │   │   ├── urql.ts
    │   │   └── utils.ts
    │   ├── _middleware.ts
    │   ├── Global.d.ts
    │   └── utils.ts
    ├── next-env.d.ts
    ├── postcss.config.js
    └── tailwind.config.js



---
File: /src/app/(nav)/about/page.tsx
---

import React from "react";
import ReactMarkdown from "react-markdown";
import gfm from "remark-gfm";

import { Card } from "../../../web/common/Card";

const readmeMarkdownText = `# About

This webpage is a search engine for probabilities. Given a query, it searches for relevant questions in various prediction markets and forecasting platforms. For example, try searching for "China", "North Korea", "Semiconductors", "COVID", "Trump", or "X-risk". In addition to search, we also provide various [tools](http://metaforecast.org/tools).

We are very interested in integrating Metaforecast with other services, and the whole thing is [open source](https://github.com/quantified-uncertainty/squiggle/tree/main/apps/metaforecast). So far, Metaforecast has been integrated with [Twitter](https://twitter.com/NunoSempere/status/1433160907308294144), [Fletcher](https://fletcher.fun/), [GlobalGuessing](https://globalguessing.com/russia-ukraine-forecasts/) and previously [Elicit](https://elicit.org/).

You can read a longer writeup with thoughts and motivations [here](https://forum.effectivealtruism.org/posts/tEo5oXeSNcB3sYr8m/introducing-metaforecast-a-forecast-aggregator-and-search), and an update thereto [here](https://www.lesswrong.com/posts/5hugQzRhdGYc6ParJ/metaforecast-update-better-search-capture-functionality-more).

## Advanced search
If your initial search doesn't succeed, you might want to try tinkering with the advanced search. In particular, try increasing or decreasing the stars threshold, or changing the number of search results shown. 

## What are stars, and how are they computed?

Star ratings—e.g. ★★★☆☆—are an indicator of the quality of an aggregate forecast for a question. These ratings currently try to reflect my own best judgment and the best judgment of forecasting experts I've asked, based on our collective experience forecasting on these platforms. Thus, stars have a strong subjective component which could be formalized and refined in the future. You can see the code used to decide how many stars to assign according to platform and various quality indicators in [platforms code](https://github.com/quantified-uncertainty/metaforecast/tree/main/apps/metaforecast/src/backend/platforms)

Also note that, whatever other redeeming features they might have, prediction markets rarely go above 95% or below 5%.

## Who is behind this?

The initial version of Metaforecast was created by [Nuño Sempere](https://nunosempere.github.io), with help from Ozzie Gooen, from the [Quantified Uncertainty Research Institute](https://quantifieduncertainty.org/). Nuño has several other forecasting-related projects, but one which might be particularly worth highlighting is this [forecasting newsletter](http://forecasting.substack.com/).

Metaforecast is currently maintained by [QURI](https://quantifieduncertainty.org/).

`;

export default function AboutPage() {
  return (
    <Card highlightOnHover={false} large={true}>
      <div className="mx-auto max-w-prose">
        <ReactMarkdown remarkPlugins={[gfm]}>
          {readmeMarkdownText}
        </ReactMarkdown>
      </div>
    </Card>
  );
}



---
File: /src/app/(nav)/dashboards/view/[id]/page.tsx
---

import Link from "next/link";
import { notFound } from "next/navigation";

import { QuestionCardsList } from "@/app/(nav)/QuestionCardsList";
import { InfoBox } from "@/web/common/InfoBox";
import { LineHeader } from "@/web/common/LineHeader";
import {
  DashboardByIdDocument,
  DashboardFragment,
} from "@/web/dashboards/queries.generated";
import { getUrqlRscClient } from "@/web/urql";

const DashboardMetadata: React.FC<{ dashboard: DashboardFragment }> = ({
  dashboard,
}) => (
  <div>
    {dashboard.title ? (
      <h1 className="mb-2 mt-2 text-center text-4xl text-gray-600">
        {dashboard.title}
      </h1>
    ) : null}

    {dashboard.creator ? (
      <p className="mb-2 mt-2 text-center text-lg text-gray-600">
        Created by:{" "}
        {dashboard.creator === "Clay Graubard" ? (
          <>
            @
            <a
              href="https://twitter.com/ClayGraubard"
              className="text-blue-600"
            >
              Clay Graubard
            </a>
          </>
        ) : (
          dashboard.creator
        )}
      </p>
    ) : null}

    {dashboard.description ? (
      <p className="mb-2 mt-2 text-center text-lg text-gray-600">
        {dashboard.description}
      </p>
    ) : null}
  </div>
);

export default async function DashboardsViewPage({
  params,
}: {
  params: Promise<{ id: string }>;
}) {
  const { id: dashboardId } = await params;
  const client = getUrqlRscClient();

  const dashboard = (
    await client.query(DashboardByIdDocument, { id: dashboardId }).toPromise()
  ).data?.result;

  if (!dashboard) {
    notFound();
  }

  return (
    <div className="my-8 flex flex-col space-y-8">
      <DashboardMetadata dashboard={dashboard} />
      <div className="grid grid-cols-1 gap-4 md:grid-cols-2 lg:grid-cols-3">
        <QuestionCardsList results={dashboard.questions} />
      </div>

      <div className="max-w-xl self-center">
        <InfoBox>Dashboards cannot be changed after they are created.</InfoBox>
      </div>

      <LineHeader>
        <Link href="/dashboards" passHref>
          Create your own dashboard
        </Link>
      </LineHeader>
    </div>
  );
}



---
File: /src/app/(nav)/dashboards/page.tsx
---

"use client";
import { useRouter } from "next/navigation";
import { useMutation } from "urql";

import { LineHeader } from "../../../web/common/LineHeader";
import { CreateDashboardDocument } from "../../../web/dashboards/queries.generated";
import { DashboardCreator } from "../../../web/display/DashboardCreator";

export default function DashboardsPage() {
  const router = useRouter();
  const [createDashboardResult, createDashboard] = useMutation(
    CreateDashboardDocument
  );

  const handleSubmit = async (data: any) => {
    const result = await createDashboard({
      input: {
        title: data.title,
        description: data.description,
        creator: data.creator,
        ids: data.ids,
      },
    });
    const dashboardId = result?.data?.result?.dashboard?.id;
    if (!dashboardId) {
      throw new Error("Couldn't create a dashboard"); // TODO - toaster
    }
    router.push(`/dashboards/view/${dashboardId}`);
  };

  return (
    <div className="my-8 flex flex-col space-y-8">
      <LineHeader>Create a dashboard!</LineHeader>

      <div className="self-center">
        <DashboardCreator handleSubmit={handleSubmit} />
      </div>
    </div>
  );
}



---
File: /src/app/(nav)/questions/[id]/EmbedSection.tsx
---

"use client";
import { FC } from "react";

import { Collapsible } from "@/web/common/Collapsible";
import { CopyParagraph } from "@/web/common/CopyParagraph";
import { QuestionWithHistoryFragment } from "@/web/fragments.generated";
import { getBasePath } from "@/web/utils";

import { Section } from "./Section";

export const EmbedSection: FC<{ question: QuestionWithHistoryFragment }> = ({
  question,
}) => {
  const url = `${getBasePath()}/questions/embed/${question.id}`;
  return (
    <Section title="Embed" id="embed">
      <CopyParagraph
        text={`<iframe src="${url}" height="600" width="600" frameborder="0" />`}
        buttonText="Copy HTML"
      />
      <div className="mt-2">
        <Collapsible title="Preview">
          {() => <iframe src={url} height="600" width="600" frameBorder="0" />}
        </Collapsible>
      </div>
    </Section>
  );
};



---
File: /src/app/(nav)/questions/[id]/layout.tsx
---

import { PropsWithChildren } from "react";

import { Card } from "@/web/common/Card";

export default function QuestionLayout({ children }: PropsWithChildren) {
  return (
    <div className="mx-auto max-w-4xl">
      <Card highlightOnHover={false} large>
        {children}
      </Card>
    </div>
  );
}



---
File: /src/app/(nav)/questions/[id]/loading.tsx
---

import Skeleton from "react-loading-skeleton";

export default function QuestionLoading() {
  return (
    <div>
      <h1 className="text-lg sm:text-3xl">
        <Skeleton />
      </h1>
      <Skeleton height={400} />
      <div className="my-4">
        <Skeleton count={5} />
      </div>
    </div>
  );
}



---
File: /src/app/(nav)/questions/[id]/page.tsx
---

import { notFound } from "next/navigation";
import React from "react";
import ReactMarkdown from "react-markdown";
import rehypeExternalLinks from "rehype-external-links";

import { CaptureQuestion } from "@/web/questions/components/CaptureQuestion";
import { IndicatorsTable } from "@/web/questions/components/IndicatorsTable";
import { QuestionChartOrVisualization } from "@/web/questions/components/QuestionChartOrVisualization";
import { QuestionInfoRow } from "@/web/questions/components/QuestionInfoRow";
import { QuestionTitle } from "@/web/questions/components/QuestionTitle";
import { QuestionPageDocument } from "@/web/questions/queries.generated";
import { getUrqlRscClient } from "@/web/urql";

import { EmbedSection } from "./EmbedSection";
import { Section } from "./Section";

export default async function QuestionPage({
  params,
}: {
  params: Promise<{ id: string }>;
}) {
  const { id } = await params;
  const client = getUrqlRscClient();

  const question =
    (await client.query(QuestionPageDocument, { id })).data?.result || null;

  if (!question) {
    notFound();
  }

  return (
    <div>
      <QuestionTitle question={question} />

      <div className="mb-5 mt-5">
        <QuestionInfoRow question={question} />
      </div>

      <div className="mb-10">
        <QuestionChartOrVisualization question={question} />
      </div>

      <div className="mx-auto max-w-prose space-y-8">
        <Section title="Question description" id="description">
          <div className="font-normal text-gray-900">
            <ReactMarkdown
              rehypePlugins={[[rehypeExternalLinks, { target: "_blank" }]]}
            >
              {question.description.replaceAll("---", "")}
            </ReactMarkdown>
          </div>
        </Section>
        <Section title="Indicators" id="indicators">
          <IndicatorsTable question={question} />
        </Section>
        <Section title="Capture" id="capture">
          <CaptureQuestion question={question} />
        </Section>
        <EmbedSection question={question} />
      </div>
    </div>
  );
}



---
File: /src/app/(nav)/questions/[id]/Section.tsx
---

import React, { FC, PropsWithChildren } from "react";

export const Section: FC<PropsWithChildren<{ title: string; id?: string }>> = ({
  title,
  children,
  id,
}) => (
  <div className="flex flex-col items-start space-y-4" id={id}>
    <div className="group w-full border-b-2 border-gray-200">
      <h2 className="text-xl leading-3 text-gray-900">
        <span>{title}</span>
        {id ? (
          <>
            {" "}
            <a
              className="hidden text-gray-300 no-underline group-hover:inline"
              href={`#${id}`}
            >
              #
            </a>
          </>
        ) : null}
      </h2>
    </div>
    <div>{children}</div>
  </div>
);



---
File: /src/app/(nav)/status/page.tsx
---

import { Card } from "@/web/common/Card";
import { getUrqlRscClient } from "@/web/urql";

import { PlatformsStatusDocument } from "./queries.generated";

export default async function StatusPage() {
  const client = getUrqlRscClient();

  const data =
    (await client.query(PlatformsStatusDocument, {})).data?.result || null;

  if (!data) {
    throw new Error("No data");
  }

  return (
    <div className="space-y-4">
      <Card>
        <p>
          Metaforecast supports many prediction platforms, and those platforms
          can sometimes change their data format, so that updates stop working.
          We try to fix these from time to time, but sometimes things break down
          for a while.
        </p>
        <p>
          Please complain in{" "}
          <a href="https://discord.gg/nsTnQTgtG6">QURI Discord</a> if you notice
          a problem.
        </p>
      </Card>
      <table className="mx-auto mb-10 table-auto border-collapse border border-gray-200 bg-white">
        <thead>
          <tr className="bg-gray-100">
            <th className="border border-gray-200 p-4">Platform</th>
            <th className="border border-gray-200 p-4">Last updated</th>
          </tr>
        </thead>
        <tbody>
          {data.map((platform) => {
            const ts = platform.lastUpdated
              ? new Date(platform.lastUpdated * 1000)
              : null;
            const isStale =
              !ts || new Date().getTime() - ts.getTime() > 2 * 86400 * 1000;
            return (
              <tr key={platform.id}>
                <td
                  className={`border border-gray-200 p-4 ${
                    isStale ? "bg-red-300" : ""
                  }`}
                >
                  {platform.label}
                </td>
                <td className="border border-gray-200 p-4">
                  <div className="text-sm">{ts ? String(ts) : null}</div>
                </td>
              </tr>
            );
          })}
        </tbody>
      </table>
    </div>
  );
}

export const dynamic = "force-dynamic";



---
File: /src/app/(nav)/tools/page.tsx
---

import React, { FC } from "react";

import Image from "next/image";
import Link from "next/link";

import { Card } from "@/web/common/Card";

import captureImg from "./capture.png";
import dashboardImg from "./dashboard.png";
import frontpageImg from "./frontpage.png";
import twitterImg from "./twitter.png";

type AnyTool = {
  title: string;
  description: string;
  img?: StaticImageData;
};

type InnerTool = AnyTool & { innerLink: string };
type ExternalTool = AnyTool & { externalLink: string };
type UpcomingTool = AnyTool;

type Tool = InnerTool | ExternalTool | UpcomingTool;

/* Display one tool */
const ToolCard: FC<Tool> = (tool) => {
  const inner = (
    <Card>
      <div className="grid content-start gap-3">
        <div className="text-lg font-medium text-gray-800">{tool.title}</div>
        <div className="text-gray-500">{tool.description}</div>
        {tool.img && (
          <Image
            src={tool.img}
            alt={tool.title}
            className="text-gray-500"
            style={{
              maxWidth: "100%",
              height: "auto",
            }}
          />
        )}
      </div>
    </Card>
  );

  if ("innerLink" in tool) {
    return (
      <Link
        href={tool.innerLink}
        passHref
        className="text‑inherit no-underline"
      >
        {inner}
      </Link>
    );
  } else if ("externalLink" in tool) {
    return (
      <a href={tool.externalLink} className="text‑inherit no-underline">
        {inner}
      </a>
    );
  } else {
    return inner;
  }
};

export default function ToolsPage() {
  const tools: Tool[] = [
    {
      title: "Search",
      description: "Find forecasting questions on many platforms.",
      innerLink: "/",
      img: frontpageImg,
    },
    {
      title: "[Beta] Present",
      description: "Present forecasts in dashboards.",
      innerLink: "/dashboards",
      img: dashboardImg,
    },
    {
      title: "Capture",
      description:
        "Capture forecasts save them to Imgur. Useful for posting them somewhere else as images. Currently rate limited by Imgur, so if you get a .gif of a fox falling flat on his face, that's why. Capture button can be found on individual questions pages.",
      innerLink: "/",
      img: captureImg,
    },
    {
      title: "Summon",
      description:
        "Summon metaforecast on Twitter by mentioning @metaforecast, or on Discord by using Fletcher and !metaforecast, followed by search terms.",
      externalLink: "https://twitter.com/metaforecast",
      img: twitterImg,
    },
    {
      title: "[Beta] Request",
      description:
        "Interact with metaforecast's GraphQL API and fetch forecasts for your application. Currently possible but documentation is poor, get in touch.",
      externalLink: "/api/graphql",
    },
    {
      title: "[Upcoming] Record",
      description: "Save your forecasts or bets.",
    },
  ];

  return (
    <div className="mb-8 grid grid-cols-1 place-content-stretch gap-4 md:grid-cols-2 lg:grid-cols-2">
      {tools.map((tool, i) => (
        <ToolCard {...tool} key={i} />
      ))}
    </div>
  );
}



---
File: /src/app/(nav)/common.ts
---

// code that can be used both on frontend and backend
export const defaultLimit = 21;

export type SearchQuery = {
  limit: number;
  query: string;
  starsThreshold: number;
  forecastsThreshold: number;
  forecastingPlatforms: string[]; // platform names
};

// it's not possible to use `forecastingPlatforms` on the frontend, because it relies on the backend code
export const defaultSearchQuery: Omit<SearchQuery, "forecastingPlatforms"> = {
  limit: 21,
  query: "",
  starsThreshold: 2,
  forecastsThreshold: 0,
};

export function searchParamsToQuery(
  searchParams: {
    [key: string]: string | string[] | undefined;
  },
  defaultForecastingPlatforms: string[]
): SearchQuery {
  // TODO - validate with zod
  const searchQuery: SearchQuery = {
    ...defaultSearchQuery,
    forecastingPlatforms: defaultForecastingPlatforms,
  };

  if (searchParams["query"]) {
    searchQuery.query = String(searchParams["query"]);
  }
  if (searchParams["starsThreshold"]) {
    searchQuery.starsThreshold = Number(searchParams["starsThreshold"]);
  }
  if (searchParams["forecastsThreshold"]) {
    searchQuery.forecastsThreshold = Number(searchParams["forecastsThreshold"]);
  }
  if (searchParams["forecastingPlatforms"]) {
    searchQuery.forecastingPlatforms = String(
      searchParams["forecastingPlatforms"]
    ).split("|");
  }

  if (searchParams["limit"]) {
    searchQuery.limit = Number(searchParams["limit"]);
  }

  return searchQuery;
}



---
File: /src/app/(nav)/hooks.ts
---

import "client-only";

import { usePathname, useRouter, useSearchParams } from "next/navigation";

import { searchParamsToQuery, SearchQuery } from "./common";

// get a function that allows to update the search query
// used by SearchForm
export function useUpdateSearchQuery() {
  const router = useRouter();

  const currentParams = useSearchParams();
  const pathname = usePathname();

  return (patch: Partial<SearchQuery>) => {
    const params = new URLSearchParams(currentParams);

    for (const [key, value] of Object.entries(patch)) {
      if (key === "forecastingPlatforms") {
        params.set(key, (value as string[]).join("|"));
      } else {
        params.set(key, String(value));
      }
      // TODO - filter out default values?
    }

    router.replace(`${pathname}?${params}`, { scroll: false });
  };
}

export function useSearchQuery(
  defaultForecastingPlatforms: string[]
): SearchQuery {
  const currentParams = useSearchParams();
  return searchParamsToQuery(
    Object.fromEntries(currentParams),
    defaultForecastingPlatforms
  );
}



---
File: /src/app/(nav)/layout.tsx
---

import React, { FC, PropsWithChildren } from "react";

import Link from "next/link";

import { ErrorBoundary } from "../../web/common/ErrorBoundary";
import { Logo2 } from "../../web/icons";
import { NavMenu } from "./NavMenu";

const Layout: FC<PropsWithChildren> = ({ children }) => {
  // The correct way to do this would be by passing a prop to Layout,
  // and to get the last updating using server side props.

  return (
    <div>
      <div>
        <nav className="bg-white shadow">
          <div className="container mx-auto max-w-7xl px-4 sm:px-6 lg:px-8">
            <div className="flex items-center justify-between">
              <div className="flex gap-8">
                <Link
                  href="/"
                  className="font-md flex items-center gap-2 no-underline"
                >
                  <Logo2 className="h-8 w-8" />
                  <span className="text-sm text-gray-700 sm:text-2xl">
                    Metaforecast
                  </span>
                </Link>
                <Link
                  href="/status"
                  className="mt-1.5 hidden self-baseline text-sm text-slate-400 no-underline hover:text-slate-900 sm:mt-2.5 sm:block"
                >
                  Status
                </Link>
              </div>

              <NavMenu />
            </div>
          </div>
        </nav>
        <main>
          <ErrorBoundary>
            <div className="container mx-auto mb-10 max-w-7xl px-4 pt-5 sm:px-6 lg:px-8">
              {children}
            </div>
          </ErrorBoundary>
        </main>
      </div>
    </div>
  );
};

export default Layout;



---
File: /src/app/(nav)/NavMenu.tsx
---

"use client";

import { FC } from "react";

import clsx from "clsx";
import Link from "next/link";
import { useSelectedLayoutSegment } from "next/navigation";

type MenuItem = {
  segment: string | null;
  link: string;
  title: string;
};

const menu: MenuItem[] = [
  {
    segment: null,
    link: "/",
    title: "Search",
  },
  {
    segment: "tools",
    link: "/tools",
    title: "Tools",
  },
  {
    segment: "about",
    link: "/about",
    title: "About",
  },
];

export const NavMenu: FC = () => {
  const segment = useSelectedLayoutSegment();

  return (
    <div className="flex space-x-4">
      {menu.map((item) => (
        <Link
          href={item.link}
          passHref
          key={item.segment || "_null"}
          className={clsx(
            "cursor-pointer border-b-2 px-2 py-4 text-sm font-medium no-underline sm:text-lg",
            segment === item.segment
              ? "border-blue-700 text-blue-700"
              : "border-transparent text-gray-400 hover:border-blue-500 hover:text-blue-500"
          )}
        >
          {item.title}
        </Link>
      ))}
    </div>
  );
};



---
File: /src/app/(nav)/page.tsx
---

import React from "react";

import { getPlatforms, getPlatformsConfig } from "@/backend/platformRegistry";

import { searchParamsToQuery } from "./common";
import { SearchForm } from "./SearchForm";
import { SearchScreen } from "./SearchScreen";
import { SearchUIProvider } from "./SearchUIProvider";

export default async function IndexPage({
  searchParams: searchParamsPromise,
}: {
  searchParams: Promise<{ [key: string]: string | string[] | undefined }>;
}) {
  const searchParams = await searchParamsPromise;
  const searchQuery = searchParamsToQuery(
    searchParams,
    getPlatforms().map((platform) => platform.name)
  );

  return (
    <SearchUIProvider>
      <SearchForm platformsConfig={getPlatformsConfig()} />
      <SearchScreen query={searchQuery} />
    </SearchUIProvider>
  );
}



---
File: /src/app/(nav)/QueryForm.tsx
---

import { ChangeEvent, FC } from "react";

type Props = {
  defaultValue: string;
  onChange: (v: string) => void;
  placeholder: string;
};

export const QueryForm: FC<Props> = ({
  defaultValue,
  onChange,
  placeholder,
}) => {
  const handleInputChange = (event: ChangeEvent<HTMLInputElement>) => {
    event.preventDefault();
    onChange(event.target.value); // In this case, the query, e.g. "COVID.19"
  };

  return (
    <form onSubmit={(e) => e.preventDefault()} className="w-full">
      <input
        className="focus:shadow-outline w-full rounded-md border-gray-300 text-gray-700 focus:outline-none"
        autoFocus
        type="text"
        defaultValue={defaultValue}
        onChange={handleInputChange}
        name="query"
        id="query"
        placeholder={placeholder}
        onSubmit={(e) => e.preventDefault()}
      />
    </form>
  );
};



---
File: /src/app/(nav)/QuestionCardsList.tsx
---

"use client";
import { FC, use } from "react";

import { QuestionFragment } from "../../web/fragments.generated";
import { QuestionCard } from "../../web/questions/components/QuestionCard";
import { SearchUIContext } from "./SearchUIProvider";

type Props = {
  results: QuestionFragment[];
};

export const QuestionCardsList: FC<Props> = ({ results }) => {
  const { showId } = use(SearchUIContext);

  if (!results) {
    return null;
  }

  return (
    <>
      {results.map((result) => (
        <QuestionCard
          key={result.id}
          question={result}
          showTimeStamp={false}
          expandFooterToFullWidth={false}
          showIdToggle={showId}
        />
      ))}
    </>
  );
};



---
File: /src/app/(nav)/SearchForm.tsx
---

"use client";
import debounce from "lodash/debounce";
import React, { FC, use, useState } from "react";

import { type PlatformConfig } from "@/backend/types";

import { MultiSelectPlatform } from "../../web/common/MultiSelectPlatform";
import { ButtonsForStars } from "../../web/display/ButtonsForStars";
import { SliderElement } from "../../web/display/SliderElement";
import { SearchQuery } from "./common";
import { useSearchQuery, useUpdateSearchQuery } from "./hooks";
import { QueryForm } from "./QueryForm";
import { SearchUIContext } from "./SearchUIProvider";

export type Props = {
  platformsConfig: PlatformConfig[];
};

export const SearchForm: FC<Props> = ({ platformsConfig }) => {
  // This is used _only_ to set the initial values of the form.
  // It shouldn't be used for `updateRoute` calls - the values could be stale because search params update asynchronously.
  // In other words, the form is uncontrolled.
  const searchQuery = useSearchQuery(
    platformsConfig.map((platform) => platform.name)
  );

  /* States */
  const [advancedOptions, showAdvancedOptions] = useState(false);

  const updateSearchQuery = useUpdateSearchQuery();

  const submit = debounce((patch: Partial<SearchQuery>) => {
    updateSearchQuery(patch);
  }, 300);

  const onChangeStars = (value: number) => {
    submit({ starsThreshold: value });
  };

  /* Change the forecast threshold */
  const displayFunctionNumForecasts = (value: number) => {
    return "# Forecasts > " + Math.round(value);
  };
  const onChangeSliderForNumForecasts = (value: number) => {
    submit({
      forecastsThreshold: Math.round(value),
    });
  };

  const onChangeSearchText = (value: string) => {
    submit({
      query: value,
    });
  };

  const onChangeSelectedPlatforms = (value: string[]) => {
    submit({
      forecastingPlatforms: value,
    });
  };

  const { showId, setShowId } = use(SearchUIContext);

  const onChangeShowId = () => setShowId(!showId);

  return (
    <div>
      <label className="mb-4 mt-4 flex flex-row items-center justify-center">
        <div className="mb-2 w-10/12">
          <QueryForm
            defaultValue={searchQuery.query}
            onChange={onChangeSearchText}
            placeholder="Find forecasts about..."
          />
        </div>

        <div className="ml-4 flex w-2/12 justify-center md:ml-2 lg:ml-0">
          <button
            className="mb-2 text-sm text-gray-500"
            onClick={() => showAdvancedOptions(!advancedOptions)}
          >
            Advanced options ▼
          </button>
        </div>
      </label>

      {advancedOptions && (
        <div className="mx-auto w-full flex-1 flex-col items-center justify-center">
          <div className="mb-4 grid grid-cols-1 content-center items-center rounded-md bg-gray-50 px-8 pb-1 pt-4 shadow sm:grid-cols-1 sm:grid-rows-4 md:grid-cols-3 md:grid-rows-2 lg:grid-cols-3 lg:grid-rows-2">
            <div className="col-start-1 col-end-4 row-start-1 row-end-1 mb-4 flex items-center justify-center md:col-start-1 md:col-end-1 md:row-span-1 md:row-start-1 md:row-end-1 lg:col-start-1 lg:col-end-1 lg:row-span-1 lg:row-start-1 lg:row-end-1">
              <SliderElement
                onChange={onChangeSliderForNumForecasts}
                defaultValue={searchQuery.forecastsThreshold}
                displayFunction={displayFunctionNumForecasts}
              />
            </div>
            <div className="col-start-1 col-end-4 row-start-2 row-end-2 mb-4 flex items-center justify-center md:col-start-2 md:col-end-2 md:row-start-1 md:row-end-1 lg:col-start-2 lg:row-start-1 lg:row-end-1">
              <ButtonsForStars
                onChange={onChangeStars}
                value={searchQuery.starsThreshold}
              />
            </div>
            <div className="col-span-3 flex items-center justify-center">
              <MultiSelectPlatform
                platformsConfig={platformsConfig}
                value={searchQuery.forecastingPlatforms}
                onChange={onChangeSelectedPlatforms}
              />
            </div>
            <button
              className="col-start-1 col-end-4 mb-2 ml-10 mr-10 mt-5 block items-center justify-center rounded border border-blue-500 bg-transparent p-10 px-4 py-2 text-center text-blue-400 hover:border-transparent hover:bg-blue-300 hover:text-white md:col-start-2 md:col-end-3 md:row-start-4 md:row-end-4 lg:col-start-2 lg:col-end-3 lg:row-start-4 lg:row-end-4"
              onClick={onChangeShowId}
            >
              Toggle show id
            </button>
          </div>
        </div>
      )}
    </div>
  );
};



---
File: /src/app/(nav)/SearchScreen.tsx
---

import { FC, Suspense } from "react";

import Skeleton from "react-loading-skeleton";

import { Card } from "@/web/common/Card";
import { QuestionFragment } from "@/web/fragments.generated";
import { getUrqlRscClient } from "@/web/urql";

import { SearchQuery } from "./common";
import { FrontpageDocument, SearchDocument } from "./queries.generated";
import { QuestionCardsList } from "./QuestionCardsList";
import { ShowMore } from "./ShowMore";

type SearchResult = {
  results: QuestionFragment[];
  hasMore: boolean;
};

async function getResults(searchQuery: SearchQuery): Promise<SearchResult> {
  const client = getUrqlRscClient();

  const withLimit = (results: QuestionFragment[]) => ({
    results: results.slice(0, searchQuery.limit),
    hasMore: results.length > searchQuery.limit,
  });

  if (searchQuery.query) {
    // search

    const response = await client.query(SearchDocument, {
      input: {
        ...searchQuery,
        limit: searchQuery.limit + 1,
      },
    });
    if (!response.data) {
      throw new Error(`GraphQL query failed: ${response.error}`);
    }
    return withLimit(response.data.result);
  } else {
    // default front page, possibly with platform and stars filters

    // this is necessary because FrontpageDocument does not support filtering, and SearchDocument requires a text query
    const filterManually = (results: QuestionFragment[]) => {
      let filteredResults = [...results];
      if (
        searchQuery.forecastingPlatforms &&
        searchQuery.forecastingPlatforms.length > 0
      ) {
        filteredResults = filteredResults.filter((result) =>
          searchQuery.forecastingPlatforms.includes(result.platform.id)
        );
      }
      if (searchQuery.starsThreshold === 4) {
        filteredResults = filteredResults.filter(
          (result) => result.qualityIndicators.stars >= 4
        );
      }
      if (searchQuery.forecastsThreshold) {
        // TODO / FIXME / remove?
      }
      return filteredResults;
    };

    const response = await client.query(FrontpageDocument, {});
    if (!response.data) {
      throw new Error(`GraphQL query failed: ${response.error}`);
    }
    return withLimit(filterManually(response.data.result));
  }
}

const LoadingSearchResultsList: FC = () => {
  return (
    <div className="grid grid-cols-1 gap-4 md:grid-cols-2 lg:grid-cols-3">
      {[...Array(9)].map((_, index) => (
        <Card key={index}>
          <Skeleton count={5} />
        </Card>
      ))}
    </div>
  );
};

const SearchResultsList: FC<SearchResult> = ({ results, hasMore }) => {
  const { length } = results;

  const roundedLength =
    length % 3 !== 0 ? length + (3 - (Math.round(length) % 3)) : length;

  return (
    <div>
      <div className="grid grid-cols-1 gap-4 md:grid-cols-2 lg:grid-cols-3">
        <QuestionCardsList results={results.slice(0, roundedLength)} />
      </div>

      {!results || hasMore ? (
        <div>
          <p className="my-4">
            {"Can't find what you were looking for?"}
            <ShowMore />
            {" or "}
            <a
              href="https://www.metaculus.com/questions/create/"
              className="cursor-pointer text-blue-800 no-underline"
              target="_blank"
            >
              suggest a question on Metaculus
            </a>
          </p>
        </div>
      ) : null}
    </div>
  );
};

const InnerSearchScreen: FC<{ query: SearchQuery }> = async ({ query }) => {
  const { results, hasMore } = await getResults(query);

  return <SearchResultsList results={results} hasMore={hasMore} />;
};

export const SearchScreen: FC<{ query: SearchQuery }> = async ({ query }) => {
  return (
    <Suspense fallback={<LoadingSearchResultsList />}>
      <InnerSearchScreen query={query} />
    </Suspense>
  );
};



---
File: /src/app/(nav)/SearchUIProvider.tsx
---

"use client";

import { createContext, FC, PropsWithChildren, useState } from "react";

export const SearchUIContext = createContext<{
  showId: boolean;
  setShowId: (showId: boolean) => void;
}>({
  showId: false,
  setShowId: () => {},
});

export const SearchUIProvider: FC<PropsWithChildren> = ({ children }) => {
  const [showId, setShowId] = useState(false);

  return (
    <SearchUIContext.Provider value={{ showId, setShowId }}>
      {children}
    </SearchUIContext.Provider>
  );
};



---
File: /src/app/(nav)/ShowMore.tsx
---

"use client";
import { FC } from "react";

import { useSearchParams } from "next/navigation";

import { defaultLimit } from "./common";
import { useUpdateSearchQuery } from "./hooks";

export const ShowMore: FC = () => {
  const updateSearchQuery = useUpdateSearchQuery();
  const searchParams = useSearchParams();
  const limit = Number(searchParams.get("limit")) || defaultLimit;

  return (
    <span
      className="cursor-pointer text-blue-800"
      onClick={() => updateSearchQuery({ limit: limit * 2 })}
    >
      {" Show more,"}
    </span>
  );
};



---
File: /src/app/(raw)/dashboards/embed/[id]/page.tsx
---

import { notFound } from "next/navigation";

import { QuestionCardsList } from "@/app/(nav)/QuestionCardsList";
import { DashboardByIdDocument } from "@/web/dashboards/queries.generated";
import { getUrqlRscClient } from "@/web/urql";

export default async function DashboardEmbedPage({
  params,
  searchParams,
}: {
  params: Promise<{ id: string }>;
  searchParams: Promise<{ [key: string]: string | string[] | undefined }>;
}) {
  const { id: dashboardId } = await params;
  const client = getUrqlRscClient();
  const rawNumCols = (await searchParams)["numCols"];

  const response = await client.query(DashboardByIdDocument, {
    id: dashboardId,
  });

  if (!response.data) {
    throw new Error(`GraphQL query failed: ${response.error}`);
  }
  const dashboard = response.data.result;

  if (!dashboard) {
    notFound();
  }

  const numCols = !rawNumCols
    ? undefined
    : Number(rawNumCols) < 5
      ? Number(rawNumCols)
      : 4;

  return (
    <div className="justify-left mb-4 mt-3 flex flex-row items-center">
      <div className="place-self-left mx-2">
        <div
          // FIXME - concatenated tailwind classes are unreliable
          className={`grid grid-cols-${numCols || 1} sm:grid-cols-${
            numCols || 1
          } md:grid-cols-${numCols || 2} lg:grid-cols-${
            numCols || 3
          } mb-6 gap-4`}
        >
          <QuestionCardsList results={dashboard.questions} />
        </div>
      </div>
    </div>
  );
}



---
File: /src/app/(raw)/questions/embed/[id]/page.tsx
---

import { notFound } from "next/navigation";

import { QuestionChartOrVisualization } from "@/web/questions/components/QuestionChartOrVisualization";
import { QuestionInfoRow } from "@/web/questions/components/QuestionInfoRow";
import { QuestionPageDocument } from "@/web/questions/queries.generated";
import { getUrqlRscClient } from "@/web/urql";

export default async function QuestionEmbedPage({
  params,
}: {
  params: Promise<{ id: string }>;
}) {
  const { id } = await params;
  const client = getUrqlRscClient();

  const question =
    (await client.query(QuestionPageDocument, { id })).data?.result || null;

  if (!question) {
    notFound();
  }

  return (
    <div className="block min-h-screen bg-white">
      <div className="h-12/12 flex w-full flex-col p-2">
        <div className="mb-1 mt-1">
          <QuestionInfoRow question={question} />
        </div>

        <div className="mb-0">
          <QuestionChartOrVisualization question={question} />
        </div>
      </div>
    </div>
  );
}



---
File: /src/app/(raw)/recursion/page.tsx
---

"use client";
import React, { useEffect } from "react";

export default function RecursionPage() {
  useEffect(() => {
    if (typeof window !== "undefined") {
      window.location.href = "https://www.youtube.com/watch?v=dQw4w9WgXcQ";
    }
  }, []);

  return (
    <div>
      <h2>You have now reached the fourth level of recursion!!</h2>
    </div>
  );
}



---
File: /src/app/(raw)/secretEmbed/page.tsx
---

import React from "react";

import { SearchDocument } from "@/app/(nav)/queries.generated";
import { getPlatforms } from "@/backend/platformRegistry";
import { QuestionFragment } from "@/web/fragments.generated";
import { QuestionCard } from "@/web/questions/components/QuestionCard";
import { getUrqlRscClient } from "@/web/urql";

export default async function SecretEmbedPage({
  searchParams: searchParamsPromise,
}: {
  searchParams: Promise<{ [key: string]: string | string[] | undefined }>;
}) {
  const searchParams = await searchParamsPromise;
  const initialQueryParameters = {
    query: "",
    starsThreshold: 2,
    forecastsThreshold: 0,
    forecastingPlatforms: getPlatforms().map((platform) => platform.name),
    ...searchParams,
  };

  let results: QuestionFragment[] = [];
  if (initialQueryParameters.query !== "") {
    const client = getUrqlRscClient();

    const response = await client
      .query(SearchDocument, {
        input: {
          ...initialQueryParameters,
          limit: 1,
        },
      })
      .toPromise();
    if (response.data?.result) {
      results = response.data.result;
    } else {
      throw new Error("GraphQL request failed");
    }
  }

  const result = results.length ? results[0] : null;

  return (
    <div className="mb-4 mt-8 flex flex-row items-center justify-center">
      <div className="w-6/12 place-self-center">
        <div>
          <div id="secretEmbed">
            {result ? (
              <QuestionCard
                question={result}
                showTimeStamp={true}
                expandFooterToFullWidth={true}
                showExpandButton={false}
              />
            ) : null}
          </div>
          <br></br>
          <div id="secretObject">
            {result ? JSON.stringify(result, null, 4) : null}
          </div>
        </div>
      </div>
    </div>
  );
}



---
File: /src/app/api/graphql/route.ts
---

import { useResponseCache } from "@graphql-yoga/plugin-response-cache";
// apollo-server-micro is problematic since v3, see https://github.com/apollographql/apollo-server/issues/5547, so we use graphql-yoga instead
import { createYoga } from "graphql-yoga";
import { NextRequest, NextResponse } from "next/server";

import { schema } from "../../../graphql/schema";

const yoga = createYoga({
  schema,
  graphqlEndpoint: "/api/graphql",
  plugins: [
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useResponseCache({
      // global cache
      session: () => null,
      ttl: 2 * 60 * 60 * 1000,
      // ^ 2h * 60 mins per hour, 60 seconds per min 1000 miliseconds per second
    }),
  ],
});

async function handler(request: NextRequest) {
  const response = await yoga.fetch(request, {
    method: request.method,
    headers: request.headers,
    body: request.body,
  });
  return new NextResponse(response.body, {
    headers: response.headers,
    status: response.status,
  });
}

export { handler as GET, handler as POST };



---
File: /src/app/layout.tsx
---

import "../styles/main.css";
import "react-loading-skeleton/dist/skeleton.css";

import { PropsWithChildren } from "react";

import { Metadata } from "next";
import PlausibleProvider from "next-plausible";

import { Root } from "./Root";

export default function RootLayout({ children }: PropsWithChildren) {
  return (
    <html>
      <head>
        <PlausibleProvider domain="metaforecast.org" />
      </head>
      <body>
        <Root>{children}</Root>
      </body>
    </html>
  );
}

export const metadata: Metadata = {
  title: "Metaforecast",
};



---
File: /src/app/Root.tsx
---

"use client";
import { FC, PropsWithChildren, useMemo } from "react";

import { createClient, ssrExchange, UrqlProvider } from "@urql/next";

import { getUrqlClientOptions } from "../web/urql";

// client component for top-level providers
export const Root: FC<PropsWithChildren> = ({ children }) => {
  const [client, ssr] = useMemo(() => {
    const ssr = ssrExchange({
      isClient: typeof window !== "undefined",
    });
    const client = createClient({
      ...getUrqlClientOptions(ssr),
      // this causes an infinite loop for some reason; also not sure if necessary with modern React
      //   suspense: true,
    });

    return [client, ssr];
  }, []);

  return (
    <UrqlProvider client={client} ssr={ssr}>
      {children}
    </UrqlProvider>
  );
};



---
File: /src/backend/cli/commands/all.ts
---

import { Command } from "@commander-js/extra-typings";

import { getPlatforms } from "@/backend/platformRegistry";
import { processPlatform } from "@/backend/platformUtils";
import { rebuildElasticDatabase } from "@/backend/utils/elastic";

import { tryCatchTryAgain } from "../utils";

export async function processAll() {
  console.log("");
  console.log("");
  console.log("");
  console.log("");
  console.log("================================");
  console.log("STARTING UP");
  console.log("================================");
  console.log("");
  console.log("");
  console.log("");
  console.log("");

  for (const platform of getPlatforms({ withDailyFetcherOnly: true })) {
    console.log("");
    console.log("");
    console.log("****************************");
    console.log(platform.name);
    console.log("****************************");
    await tryCatchTryAgain(async () => await processPlatform(platform));
    console.log("****************************");
  }

  console.log("Rebuilding Elasticsearch database");
  await rebuildElasticDatabase();
}

export function addAllCommand(program: Command) {
  program
    .command("all")
    .description("process all platforms and rebuild elasticsearch database")
    .action(processAll);
}



---
File: /src/backend/cli/commands/elastic.ts
---

import { Command } from "@commander-js/extra-typings";

import { rebuildElasticDatabase } from "@/backend/utils/elastic";

export function addElasticCommand(program: Command) {
  program
    .command("elastic")
    .description("rebuild elasticsearch database")
    .action(async () => {
      await rebuildElasticDatabase();
    });
}



---
File: /src/backend/cli/commands/frontpage.ts
---

import { Command } from "@commander-js/extra-typings";

import { rebuildFrontpage } from "@/backend/frontpage";

export function addFrontpageCommand(program: Command) {
  program
    .command("frontpage")
    .description("rebuild frontpage")
    .action(async () => {
      await rebuildFrontpage();
    });
}



---
File: /src/backend/cli/commands/platform-commands.ts
---

import { type Command } from "@commander-js/extra-typings";

import { getPlatforms } from "../../platformRegistry";
import { processPlatform } from "../../platformUtils";

export function addPlatformCommands(program: Command) {
  for (const platform of getPlatforms()) {
    const command = program
      .command(platform.name)
      .description(`download predictions from ${platform.name}`)
      .action(async () => {
        await processPlatform(platform);
      });

    platform.extendCliCommand?.(command);
  }
}



---
File: /src/backend/cli/commands/shell.ts
---

import { Command } from "@commander-js/extra-typings";
import { select, Separator } from "@inquirer/prompts";

import { rebuildFrontpage } from "@/backend/frontpage";
import { getPlatforms } from "@/backend/platformRegistry";
import { rebuildElasticDatabase } from "@/backend/utils/elastic";

import { processAll } from "./all";

export function addShellCommand(program: Command) {
  program
    .command("shell", { isDefault: true })
    .argument("[command]")
    .description("interactive shell")
    .action(async (command) => {
      // if command name would be known, it would be handled by other commands
      if (command) {
        throw new Error(`Command ${command} not found`);
      }

      const answer = await select({
        message: "Choose one option, wisely:",
        pageSize: 100,
        choices: [
          new Separator("─── Daily fetchers ───"),
          ...getPlatforms({ withDailyFetcherOnly: true }).map((platform) => ({
            name: platform.name,
            value: async () => {
              await program.parseAsync([platform.name]);
            },
          })),
          new Separator("─── Other commands ───"),
          {
            name: "Elastic",
            value: rebuildElasticDatabase,
          },
          {
            name: "Frontpage",
            value: rebuildFrontpage,
          },
          {
            name: "All",
            value: processAll,
          },
        ],
      });

      await answer();
      process.exit();
    });
}



---
File: /src/backend/cli/index.ts
---

import "dotenv/config";

import { Command } from "@commander-js/extra-typings";

import { addAllCommand } from "./commands/all";
import { addElasticCommand } from "./commands/elastic";
import { addFrontpageCommand } from "./commands/frontpage";
import { addPlatformCommands } from "./commands/platform-commands";
import { addShellCommand } from "./commands/shell";

function makeProgram() {
  const program = new Command();

  addPlatformCommands(program);
  addElasticCommand(program);
  addFrontpageCommand(program);
  addAllCommand(program);

  addShellCommand(program);

  return program;
}

function main() {
  const program = makeProgram();
  program.parse();
}

main();



---
File: /src/backend/cli/utils.ts
---

import { sleep } from "../utils/sleep";

export async function tryCatchTryAgain(fun: () => Promise<void>) {
  try {
    console.log("Initial try");
    await fun();
  } catch (error) {
    sleep(10000);
    console.log("Second try");
    console.log(error);
    try {
      await fun();
    } catch (error) {
      console.log(error);
    }
  }
}



---
File: /src/backend/manual/count-uniq-history-entries.ts
---

import "dotenv/config";

import crypto from "crypto";

import { prisma } from "@quri/metaforecast-db";

// This script counts the number of unique history entries in the database, to check how many duplicates there are.
// It's not used anywhere, but I'm keeping it here for now.
async function main() {
  let cursor = 0;
  let total = 0;
  const take = 1000;
  const uniq = new Set<string>();

  while (1) {
    const rows = await prisma.history.findMany({
      take,
      ...(cursor
        ? {
            skip: 1,
            cursor: { pk: cursor },
          }
        : {}),
    });

    total += rows.length;

    for (const { pk, fetched, ...row } of rows) {
      uniq.add(
        // hash the entire entry
        crypto.createHash("sha256").update(JSON.stringify(row)).digest("hex")
      );
    }
    console.log(`Total: ${total}, uniq: ${uniq.size}`);

    if (rows.length === take) {
      cursor = rows[rows.length - 1].pk;
    } else {
      break;
    }
  }
}

main();



---
File: /src/backend/platforms/manifold/api.ts
---

import { z } from "zod";

import { fetchJson } from "@/backend/utils/fetchUtils";

import {
  fullMarketSchema,
  groupSchema,
  liteMarketSchema,
  ManifoldApiFullMarket,
  ManifoldApiGroup,
  ManifoldApiLiteMarket,
} from "./apiSchema";

/**
 * Low-level API functions for Manifold. Should map to the Manifold API pretty closely.
 */

// See https://docs.manifold.markets/api
const ENDPOINT = "https://api.manifold.markets/v0";

const v0MarketsSchema = z.array(liteMarketSchema);

export type FetchParams = {
  upToUpdatedTime?: Date;
  beforeId?: string;
};

export async function fetchAllMarketsLite({
  upToUpdatedTime,
  beforeId,
}: FetchParams = {}): Promise<ManifoldApiLiteMarket[]> {
  const endpoint = `${ENDPOINT}/markets`;

  let lastId = beforeId ?? "";
  const allMarkets: ManifoldApiLiteMarket[] = [];
  let counter = 1;
  while (1) {
    const url = new URL(endpoint);
    url.searchParams.set("sort", "updated-time");
    if (lastId) {
      url.searchParams.set("before", lastId);
    }
    console.log(`Query #${counter}: ${url}`);

    const json = await fetchJson(url.toString());
    const markets = v0MarketsSchema.parse(json);

    let filteredMarkets = markets;
    if (upToUpdatedTime) {
      filteredMarkets = markets.filter(
        (market) => market.lastUpdatedTime! >= upToUpdatedTime // keep only the markets that were updated after upToUpdatedTime
      );
    }

    if (filteredMarkets.length === 0) {
      break;
    }

    allMarkets.push(...filteredMarkets);
    {
      const total = allMarkets.length;
      const added = filteredMarkets.length;
      const minDate = filteredMarkets[0].lastUpdatedTime!;
      const maxDate = filteredMarkets.at(-1)?.lastUpdatedTime!;
      console.log(
        `Total: ${total}, added: ${added}, minDate: ${minDate}, maxDate: ${maxDate}`
      );
    }

    lastId = markets[markets.length - 1].id;
    counter = counter + 1;
  }
  return allMarkets;
}

export async function fetchFullMarket(
  marketId: string
): Promise<ManifoldApiFullMarket> {
  const endpoint = `${ENDPOINT}/market/${marketId}`;
  const data = await fetchJson(endpoint);
  return fullMarketSchema.parse(data);
}

export async function fetchGroup(slug: string): Promise<ManifoldApiGroup> {
  console.log(`Fetching group ${slug}`);
  const endpoint = `${ENDPOINT}/group/${slug}`;
  const data = await fetchJson(endpoint, { retries: 1 });
  return groupSchema.parse(data);
}



---
File: /src/backend/platforms/manifold/apiSchema.ts
---

import { z } from "zod";

const numberToDate = z.number().transform((n) => {
  // Prisma can't handle large dates correctly:
  // > Could not convert argument value Object {"$type": String("DateTime"), "value": String("+010000-01-02T07:59:00.000Z")} to ArgumentValue.
  // Example with a large date: https://api.manifold.markets/v0/market/fz1K2xeIUsUtmR8SIHcE, https://manifold.markets/d6e/will-i-ever-give-you-up
  // So we reduce the value to 1e14, which is around year 5000 or so. (I'm not sure what the actual limit is.)
  return new Date(Math.min(n, 1e14));
});

// via https://docs.manifold.markets/api#get-v0markets, LiteMarket type
export const liteMarketSchema = z.object({
  // Unique identifier for this market
  id: z.string(),

  // Attributes about the creator
  creatorId: z.string(),
  creatorUsername: z.string(),
  creatorName: z.string(),
  creatorAvatarUrl: z.string().optional(),

  // Market attributes
  createdTime: numberToDate, // When the market was created
  closeTime: numberToDate.optional(), // Min of creator's chosen date, and resolutionTime
  question: z.string(),

  // Note: This url always points to https://manifold.markets, regardless of what instance the api is running on.
  // This url includes the creator's username, but this doesn't need to be correct when constructing valid URLs.
  //   i.e. https://manifold.markets/Austin/test-market is the same as https://manifold.markets/foo/test-market
  url: z.string(),

  outcomeType: z.string(), // BINARY, FREE_RESPONSE, MULTIPLE_CHOICE, NUMERIC, PSEUDO_NUMERIC, BOUNTIED_QUESTION, POLL, or ...
  mechanism: z.string(), // dpm-2, cpmm-1, or cpmm-multi-1

  probability: z.number().optional(),
  pool: z.record(z.number()).optional(), // For CPMM markets, the number of shares in the liquidity pool. For DPM markets, the amount of mana invested in each answer.
  p: z.number().optional(), // CPMM markets only, probability constant in y^p * n^(1-p) = k
  totalLiquidity: z.number().optional(), // CPMM markets only, the amount of mana deposited into the liquidity pool

  // PSEUDO_NUMERIC markets only
  value: z.number().optional(), // the current market value, which is mapped from probability using min, max, and isLogScale.
  min: z.number().optional(), // the minimum resolvable value
  max: z.number().optional(), // the maximum resolvable value
  isLogScale: z.boolean().optional(), // if true `number = (max - min + 1)^probability + minstart - 1`, otherwise `number = min + (max - min) * probability`

  volume: z.number(),
  volume24Hours: z.number(),

  isResolved: z.boolean(),
  resolutionTime: numberToDate.optional(),
  resolution: z.string().optional(),
  resolutionProbability: z.number().optional(), // Used for BINARY markets resolved to MKT
  uniqueBettorCount: z.number(),

  lastUpdatedTime: numberToDate.optional(),
  lastBetTime: numberToDate.optional(),

  token: z.enum(["MANA", "CASH"]).optional(), // mana or prizecash question
  siblingContractId: z.string().optional(), // id of the prizecash or mana version of this question that you get to by toggling.
});

export type ManifoldApiLiteMarket = z.infer<typeof liteMarketSchema>;

// A complete market, along with answers (for free response markets)
// Based on type FullMarket in https://docs.manifold.markets/api#get-v0marketmarketid
export const fullMarketSchema = liteMarketSchema.extend({
  // multi markets only
  answers: z
    .array(
      z.object({
        id: z.string(),
        createdTime: numberToDate,
        index: z.number(),
        text: z.string(),
        probability: z.number(),
        pool: z.record(z.number()).optional(),
      })
    )
    .optional(),
  // multi markets only, whether answers are dependant (that is add up to 100%, typically used when only one answer should win). Always true for dpm-2 multiple choice and free response
  shouldAnswersSumToOne: z.boolean().optional(),
  // multi markets only, who can add answers
  addAnswersMode: z.enum(["ANYONE", "ONLY_CREATOR", "DISABLED"]).optional(),
  // poll only
  options: z
    .array(
      z.object({
        text: z.string(),
        votes: z.number(),
      })
    )
    .optional(),
  totalBounty: z.number().optional(), // bounty only
  bountyLeft: z.number().optional(), // bounty only
  // Rich text content. See https://tiptap.dev/guide/output#option-1-json
  // Assuming JSONContent is a complex type, using z.any() for now
  description: z.any(),
  // string description without formatting, images, or embeds
  // Note: sometimes (for old markets) it's missing and `description` is a string.
  textDescription: z.string().default(""),
  coverImageUrl: z.string().nullable().optional(),
  // topics tagged in this market
  groupSlugs: z.array(z.string()).optional(),
});

export type ManifoldApiFullMarket = z.infer<typeof fullMarketSchema>;

/*
 * // example:
 * // https://api.manifold.markets/v0/group/covid-d7a9361d772d
 * id: "QVtAndZbd4jbfuKPSEDS",
 * slug: "covid-d7a9361d772d",
 * name: "COVID",
 * about: "",
 * creatorId: "BnrZm9NE0tgrR68qZwYoxtjKyhQ2",
 * createdTime: 1658261761000,
 * totalMembers: 350,
 * privacyStatus: "public",
 * importanceScore: 0.5520822871475163,
 */
export const groupSchema = z.object({
  id: z.string(),
  slug: z.string(),
  name: z.string(),
  // TODO - more fields
});

export type ManifoldApiGroup = z.infer<typeof groupSchema>;



---
File: /src/backend/platforms/manifold/extendedTables.ts
---

// Saving data to Manifold-specific tables.

import fs from "fs/promises";
import { z } from "zod";

import { ManifoldMarket, prisma, Prisma } from "@quri/metaforecast-db";

import { fetchFullMarket, fetchGroup } from "./api";
import { fullMarketSchema, ManifoldApiFullMarket } from "./apiSchema";

/**
 * Saves a full market from API to Manifold-specific tables and returns the Prisma market object.
 */
const invalidGroupSlugsCache = new Set<string>();
async function saveExtendedMarket(
  market: ManifoldApiFullMarket
): Promise<ManifoldMarket> {
  const {
    // extracted to separate User table
    creatorUsername,
    creatorName,
    creatorAvatarUrl,
    // other tables
    answers = [],
    groupSlugs = [],
    ...data
  } = market;

  const creator = await prisma.manifoldMarketUser.upsert({
    where: {
      id: data.creatorId,
    },
    update: {
      name: creatorName,
      username: creatorUsername,
      avatarUrl: creatorAvatarUrl,
    },
    create: {
      id: data.creatorId,
      name: creatorName,
      username: creatorUsername,
      avatarUrl: creatorAvatarUrl,
    },
  });

  const existingGroups = await prisma.manifoldGroup.findMany({
    where: {
      slug: {
        in: groupSlugs,
      },
    },
  });
  const groupIds = existingGroups.map((g) => g.id);

  // Look for non-existing groups, fetch them and create them
  const groupsToCreate = groupSlugs.filter(
    (slug) => !existingGroups.some((g) => g.slug === slug)
  );

  for (const groupSlug of groupsToCreate) {
    if (invalidGroupSlugsCache.has(groupSlug)) {
      continue;
    }

    try {
      const group = await fetchGroup(groupSlug);
      const dbGroup = await prisma.manifoldGroup.create({
        data: {
          id: group.id,
          slug: group.slug,
          name: group.name,
        },
      });
      groupIds.push(dbGroup.id);
    } catch {
      // not fatal - some old markets can have invalid group slugs
      console.warn(`${groupSlug} group not found`);
      invalidGroupSlugsCache.add(groupSlug);
    }
  }

  return await prisma.$transaction<ManifoldMarket>(async (tx) => {
    const dbMarket = await tx.manifoldMarket.upsert({
      where: {
        id: data.id,
      },
      update: {
        ...data,
        creatorId: creator.id,
      },
      create: {
        ...data,
        options: data.options ?? Prisma.JsonNull,
        creatorId: creator.id,
      },
      include: {
        creator: true,
        answers: true,
        groups: {
          include: {
            group: true,
          },
        },
      },
    });

    // Upsert answers
    for (const answer of answers) {
      await tx.manifoldMarketAnswer.upsert({
        where: {
          id: answer.id,
        },
        update: {
          ...answer,
          marketId: dbMarket.id,
        },
        create: {
          ...answer,
          marketId: dbMarket.id,
        },
      });
    }

    // Update group slugs
    {
      const existingRelations = await tx.manifoldMarketGroup.findMany({
        where: {
          marketId: dbMarket.id,
        },
      });
      const existingGroupIds = existingRelations.map((r) => r.groupId);

      const relationsToCreate = groupIds.filter(
        (id) => !existingGroupIds.includes(id)
      );
      const relationsToDelete = existingGroupIds.filter(
        (id) => !groupIds.includes(id)
      );

      await tx.manifoldMarketGroup.createMany({
        data: relationsToCreate.map((groupId) => ({
          marketId: dbMarket.id,
          groupId: groupId,
        })),
      });

      await tx.manifoldMarketGroup.deleteMany({
        where: {
          marketId: dbMarket.id,
          groupId: {
            in: relationsToDelete,
          },
        },
      });
    }

    return dbMarket;
  });
}

/**
 * Process full markets and save them to extended tables.
 * Returns Prisma market objects.
 */
export async function saveMarketsToExtendedTables(
  markets: ManifoldApiFullMarket[]
): Promise<ManifoldMarket[]> {
  const prismaMarkets: ManifoldMarket[] = [];

  for (let i = 0; i < markets.length; i++) {
    const market = markets[i];
    const prismaMarket = await saveExtendedMarket(market);
    prismaMarkets.push(prismaMarket);
    if ((i + 1) % 1000 === 0) {
      console.log(`Saved market ${market.id} (${i + 1} / ${markets.length})`);
    }
  }

  return prismaMarkets;
}

/**
 * Imports markets from a JSON archive file and saves to extended tables.
 * Returns the saved Prisma market objects.
 */
export async function storeMarketsFromJsonArchiveFile(
  filename: string
): Promise<ManifoldMarket[]> {
  console.log("Loading JSON archive");
  const file = await fs.readFile(filename, "utf8");
  console.log("Parsing JSON");
  const json = JSON.parse(file);
  console.log("Parsing with zod");

  const parsedArray = z.array(z.any()).parse(json);
  const fullMarkets: ManifoldApiFullMarket[] = [];

  // process each market in the JSON archive
  for (let i = 0; i < parsedArray.length; i++) {
    const market = parsedArray[i];

    if ((i + 1) % 1000 === 0) {
      console.log(
        `Processing market ${market.id} (${i + 1} / ${parsedArray.length})`
      );
    }

    try {
      if (market.outcomeType === "QUADRATIC_FUNDING") {
        // quadratic funding markets are not available anymore
        continue;
      }

      if (!("url" in market)) {
        // archive markets can miss URL
        market.url = `https://manifold.markets/${market.creatorUsername}/${market.slug}`;
      }

      if ("prob" in market) {
        market.probability = market.prob;
      }

      if ("answers" in market) {
        // upgrade legacy format
        for (const answer of market.answers) {
          if (!answer.probability) {
            answer.probability = answer.prob;
          }
          if (answer.poolYes && answer.poolNo) {
            answer.pool = {
              YES: answer.poolYes,
              NO: answer.poolNo,
            };
          }
        }
      }

      const parsed = fullMarketSchema.safeParse(market);
      if (!parsed.success) {
        console.log(JSON.stringify(parsed.error.issues, null, 2));
        console.log(market);
        throw new Error(
          "JSON validation failed for market " + (market as any).id
        );
      }

      fullMarkets.push(parsed.data);
    } catch (e) {
      console.error(e);
      console.log("Retrying with API...");
      // if there's an error, try to fetch from API
      try {
        const fullMarket = await fetchFullMarket(market.id);
        fullMarkets.push(fullMarket);
      } catch (apiError) {
        console.error("Failed to fetch from API as well:", apiError);
      }
    }
  }

  // Save all markets to extended tables
  return await saveMarketsToExtendedTables(fullMarkets);
}

/**
 * Imports a single market by ID, fetches it from API and saves to extended tables.
 * Returns the Prisma market object.
 */
export async function importSingleMarket(id: string): Promise<ManifoldMarket> {
  const fullMarket = await fetchFullMarket(id);
  return await saveExtendedMarket(fullMarket);
}



---
File: /src/backend/platforms/manifold/fetch.ts
---

import { fetchAllMarketsLite, fetchFullMarket, FetchParams } from "./api";
import { ManifoldApiFullMarket, ManifoldApiLiteMarket } from "./apiSchema";

/**
 * Fetches all lite markets from the Manifold API.
 */
export async function fetchLiteMarkets({
  upToUpdatedTime,
  beforeId,
}: FetchParams = {}): Promise<{
  liteMarkets: ManifoldApiLiteMarket[];
  latestUpdateTime?: Date;
}> {
  const liteMarkets = await fetchAllMarketsLite({
    upToUpdatedTime,
    beforeId,
  });
  console.log(`Fetched ${liteMarkets.length} markets from API`);

  // Get the latest update time for platform state
  const latestUpdateTime =
    liteMarkets.length > 0 ? liteMarkets[0].lastUpdatedTime : undefined;

  return {
    liteMarkets,
    latestUpdateTime,
  };
}

/**
 * Upgrades lite markets to full markets by fetching additional data.
 */
export async function upgradeLiteMarketsToFull(
  liteMarkets: ManifoldApiLiteMarket[]
): Promise<ManifoldApiFullMarket[]> {
  const fullMarkets: ManifoldApiFullMarket[] = [];

  for (const market of liteMarkets) {
    console.log(`Fetching full market ${market.url}`);
    const fullMarket = await fetchFullMarket(market.id);
    fullMarkets.push(fullMarket);
  }

  return fullMarkets;
}

export async function fetchFullMarkets(params: FetchParams = {}): Promise<{
  fullMarkets: ManifoldApiFullMarket[];
  latestUpdateTime?: Date;
}> {
  const { liteMarkets, latestUpdateTime } = await fetchLiteMarkets(params);
  const fullMarkets = await upgradeLiteMarketsToFull(liteMarkets);
  return { fullMarkets, latestUpdateTime };
}



---
File: /src/backend/platforms/manifold/fetchAndStore.ts
---

import { ManifoldMarket } from "@quri/metaforecast-db";

import { FetchParams } from "./api";
import { saveMarketsToExtendedTables } from "./extendedTables";
import { fetchFullMarkets } from "./fetch";

/**
 * High-level function that orchestrates the fetching pipeline.
 * 1. Fetch lite markets from API
 * 2. Upgrade lite markets to full markets
 * 3. Save to extended tables and return Prisma objects
 */
export async function fetchAndStoreMarketsFromApi(
  params: FetchParams = {}
): Promise<{
  prismaMarkets: ManifoldMarket[];
  latestUpdateTime?: Date;
}> {
  const { fullMarkets, latestUpdateTime } = await fetchFullMarkets(params);

  // Step 3: Save to extended tables and get Prisma objects
  const prismaMarkets = await saveMarketsToExtendedTables(fullMarkets);

  return {
    prismaMarkets,
    latestUpdateTime,
  };
}



---
File: /src/backend/platforms/manifold/index.ts
---

import { z } from "zod";

import { ManifoldMarket } from "@quri/metaforecast-db";

import {
  saveQuestionsWithStats,
  saveResolvedQuestions,
} from "@/backend/dbUtils";
import { getPlatformState, setPlatformState } from "@/backend/platformUtils";
import { FetchedQuestion, Platform } from "@/backend/types";

import { average, sum } from "../../../utils";
import {
  importSingleMarket,
  storeMarketsFromJsonArchiveFile,
} from "./extendedTables";
import { fetchAndStoreMarketsFromApi } from "./fetchAndStore";
import { marketsToQuestions } from "./marketsToQuestions";

/**
 * Separates markets into resolved and unresolved.
 * This is now done at the highest level for better abstraction.
 */
function separateResolvedMarkets(markets: ManifoldMarket[]): {
  unresolvedMarkets: ManifoldMarket[];
  resolvedQuestionIds: string[];
} {
  const platformName = "manifold";
  const unresolvedMarkets: ManifoldMarket[] = [];
  const resolvedQuestionIds: string[] = [];

  console.log(`Sorting out ${markets.length} markets`);
  for (const market of markets) {
    if (market.isResolved) {
      resolvedQuestionIds.push(`${platformName}-${market.id}`);
    } else {
      unresolvedMarkets.push(market);
    }
  }
  console.log(
    `${unresolvedMarkets.length} unresolved markets, ${resolvedQuestionIds.length} resolved markets`
  );

  return { unresolvedMarkets, resolvedQuestionIds };
}

/**
 * Common processing pipeline for markets, showing statistics and saving to DB.
 */
async function processMarketsAndSave(
  platform: Platform,
  prismaMarkets: ManifoldMarket[],
  options: {
    replaceAll?: boolean;
    index?: boolean;
  } = {}
) {
  const { unresolvedMarkets, resolvedQuestionIds } =
    separateResolvedMarkets(prismaMarkets);
  const questions = marketsToQuestions(unresolvedMarkets);

  showStatistics(questions);

  await saveQuestionsWithStats({
    platform,
    fetchedQuestions: questions,
    ...options,
  });

  await saveResolvedQuestions(resolvedQuestionIds);

  return { questions, resolvedQuestionIds };
}

/**
 * The code for this platform has been refactored to follow a clear pipeline:
 * 1. API or JSON archive -> fetch and parse to ApiFullMarket[]
 * 2. ApiFullMarket[] -> extended tables (i.e., manifold-specific tables)
 * 3. Prisma-level objects -> `questions` table and Elasticsearch
 */

const platformName = "manifold";

function showStatistics(questions: FetchedQuestion[]) {
  console.log(`Unresolved markets: ${questions.length}`);

  const num2StarsOrMore = questions.filter(
    (result) => manifold.calculateStars(result) >= 2
  );

  console.log(
    `Manifold has ${num2StarsOrMore.length} markets with 2 stars or more`
  );

  if (questions.length > 0) {
    console.log(
      `Mean volume: ${
        sum(
          questions.map((question) => question.qualityindicators.volume || 0)
        ) / questions.length
      }; mean pool: ${
        sum(
          questions.map((question) =>
            average(Object.values(question.qualityindicators.pool || {}))
          )
        ) / questions.length
      }`
    );
  }
}

export const manifold: Platform<z.ZodObject<{ lastFetched: z.ZodNumber }>> = {
  name: platformName,
  label: "Manifold Markets",
  color: "#793466",
  extendCliCommand(command) {
    command
      .command("fetch-one")
      .argument("<id>", "Fetch a single question by id")
      .description(
        "Saves only to the extended tables, not to the main 'questions' table"
      )
      .action(async (id) => {
        await importSingleMarket(id);
      });

    command
      .command("json-archive")
      .argument("<filename>", "Filename of the JSON archive")
      .action(async (filename) => {
        const prismaMarkets = await storeMarketsFromJsonArchiveFile(filename);
        await processMarketsAndSave(this, prismaMarkets, { index: true });
      });

    command
      .command("fetch-new")
      .option(
        "--up-to-updated-time <timestamp>",
        "Fetch markets up to this timestamp; defaults to platform state. If set, state won't be updated."
      )
      .option(
        "--before <id>",
        "Fetch markets before this id; useful for resuming"
      )
      .action(async (options) => {
        const state = await getPlatformState(this);
        const upToUpdatedTime = options.upToUpdatedTime
          ? new Date(options.upToUpdatedTime)
          : state?.lastFetched
            ? new Date(state.lastFetched)
            : new Date(Date.now() - 1000 * 60 * 60 * 24); // 1 day ago

        const { prismaMarkets, latestUpdateTime } =
          await fetchAndStoreMarketsFromApi({
            upToUpdatedTime,
            beforeId: options.before,
          });

        await processMarketsAndSave(this, prismaMarkets, { index: true });

        if (latestUpdateTime && !options.upToUpdatedTime && !options.before) {
          await setPlatformState(this, {
            lastFetched: latestUpdateTime.getTime(),
          });
        }
      });

    // not a daily fetcher because we'll usually use an incremental fetcher
    // this command probably won't work, because it will run out of memory
    command.command("fetch-all").action(async () => {
      const { prismaMarkets } = await fetchAndStoreMarketsFromApi();
      await processMarketsAndSave(this, prismaMarkets, { replaceAll: true });
    });
  },

  calculateStars(data) {
    if (
      (data.qualityindicators.numforecasters || 0) > 10 ||
      (data.qualityindicators.volume || 0) > 1000
    ) {
      return 2;
    } else {
      return 1;
    }
  },

  stateSchema: z.object({
    lastFetched: z.number(), // timestamp
  }),
};



---
File: /src/backend/platforms/manifold/marketsToQuestions.ts
---

import { ManifoldMarket } from "@quri/metaforecast-db";

import { FetchedQuestion } from "@/backend/types";
import { QuestionOption } from "@/common/types";

const platformName = "manifold";

/**
 * Converts Prisma-level ManifoldMarket objects to FetchedQuestion objects.
 * This is the third step in the pipeline, after API fetching and saving to extended tables.
 */
export function marketsToQuestions(
  markets: ManifoldMarket[]
): FetchedQuestion[] {
  const questions: FetchedQuestion[] = [];

  for (const market of markets) {
    // Skip markets without probability (multiple choice questions)
    if (market.probability === undefined || market.probability === null) {
      continue;
    }

    const probability = market.probability;
    const options: QuestionOption[] = [
      {
        name: "Yes",
        probability,
        type: "PROBABILITY",
      },
      {
        name: "No",
        probability: 1 - probability,
        type: "PROBABILITY",
      },
    ];

    const question: FetchedQuestion = {
      id: `${platformName}-${market.id}`,
      title: market.question,
      url: market.url,
      description: market.textDescription,
      options,
      qualityindicators: {
        createdTime: market.createdTime,
        volume24Hours: market.volume24Hours,
        volume: market.volume,
        numforecasters: market.uniqueBettorCount,
        pool: market.pool as Record<string, number> | undefined, // normally liquidity
      },
    };

    questions.push(question);
  }

  return questions;
}



---
File: /src/backend/platforms/metaculus/api.ts
---




---
File: /src/backend/platforms/metaculus/api2.ts
---

import Ajv, { JTDDataType, ValidateFunction } from "ajv/dist/jtd";

import { fetchJson } from "@/backend/utils/fetchUtils";

// Type examples:
// - group: https://www.metaculus.com/api2/questions/9866/
// - claim: https://www.metaculus.com/api2/questions/9668/
// - subquestion forecast: https://www.metaculus.com/api2/questions/10069/
// - basic forecast: https://www.metaculus.com/api2/questions/11005/

const commonProps = {
  id: {
    type: "uint32",
  },
  title: {
    type: "string",
  },
} as const;

const predictableProps = {
  publish_time: {
    type: "string",
  },
  close_time: {
    type: "string",
  },
  resolve_time: {
    type: "string",
  },
  resolution: {
    type: "float64",
    nullable: true,
  },
  possibilities: {
    properties: {
      type: {
        // Enum["binary", "continuous"], via https://github.com/quantified-uncertainty/metaforecast/pull/84#discussion_r878240875
        // but metaculus might add new values in the future and we don't want the fetcher to break
        type: "string",
      },
    },
    additionalProperties: true,
  },
  prediction_count: {
    type: "uint32",
  },
  community_prediction: {
    properties: {
      full: {
        // q1/q2/q3 can be missing, e.g. https://www.metaculus.com/api2/questions/1633/
        optionalProperties: {
          q1: {
            type: "float64",
          },
          q2: {
            type: "float64",
          },
          q3: {
            type: "float64",
          },
        },
        additionalProperties: true,
      },
    },
    nullable: true,
    additionalProperties: true,
  },
} as const;

const pageProps = {
  page_url: {
    type: "string",
  },
  group: {
    type: "uint32",
    nullable: true,
  },
} as const;

// these are missing in /api2/questions/ requests, and building two schemas is too much pain
const optionalPageProps = {
  description: {
    type: "string",
  },
  description_html: {
    type: "string",
  },
} as const;

const questionSchema = {
  discriminator: "type",
  mapping: {
    forecast: {
      properties: {
        ...commonProps,
        ...pageProps,
        ...predictableProps,
      },
      optionalProperties: {
        ...optionalPageProps,
      },
      additionalProperties: true,
    },
    group: {
      properties: {
        ...commonProps,
        ...pageProps,
      },
      optionalProperties: {
        ...optionalPageProps,
        sub_questions: {
          elements: {
            properties: {
              ...commonProps,
              ...predictableProps,
            },
            additionalProperties: true,
          },
        },
      },
      additionalProperties: true,
    },
    // we're not interested in claims currently (but we should be?)
    claim: {
      properties: {
        ...commonProps,
        ...pageProps,
      },
      optionalProperties: {
        ...optionalPageProps,
      },
      additionalProperties: true,
    },
    discussion: {
      optionalProperties: {
        ...optionalPageProps,
      },
      additionalProperties: true,
    },
  },
} as const;

const knownQuestionTypes = Object.keys(questionSchema.mapping);

const shallowMultipleQuestionsSchema = {
  properties: {
    results: {
      elements: {
        properties: {
          type: {
            type: "string",
          },
        },
        additionalProperties: true,
      },
    },
    next: {
      type: "string",
      nullable: true,
    },
  },
  additionalProperties: true,
} as const;

export type ApiCommon = JTDDataType<{
  properties: typeof commonProps;
}>;
export type ApiPredictable = JTDDataType<{
  properties: typeof predictableProps;
}>;
export type ApiQuestion = JTDDataType<typeof questionSchema>;

type ApiShallowMultipleQuestions = JTDDataType<
  typeof shallowMultipleQuestionsSchema
>;

export type ApiMultipleQuestions = {
  results: ApiQuestion[];
  next: ApiShallowMultipleQuestions["next"]; // Omit<ApiShallowMultipleQuestions, "results"> doesn't work correctly here
};

const validateQuestion = new Ajv().compile<ApiQuestion>(questionSchema);
const validateShallowMultipleQuestions =
  new Ajv().compile<ApiShallowMultipleQuestions>(
    shallowMultipleQuestionsSchema
  );

async function fetchAndValidate<T = unknown>(
  url: string,
  validator: ValidateFunction<T>
): Promise<T> {
  const data = await fetchJson(url);
  if (validator(data)) {
    return data;
  } else {
    console.log(data);
    throw new Error(
      `Response validation for url ${url} failed: ` +
        JSON.stringify(validator.errors, null, 4)
    );
  }
}

export async function fetchApiQuestions(
  next: string
): Promise<ApiMultipleQuestions> {
  const data = await fetchAndValidate(next, validateShallowMultipleQuestions);

  const results: ApiQuestion[] = [];

  for (const result of data.results) {
    if (!knownQuestionTypes.includes(result.type)) {
      console.warn(`Unknown result type ${result.type}, skipping`);
      continue;
    }

    if (!validateQuestion(result)) {
      console.log(
        `Response validation failed: ` + JSON.stringify(validateQuestion.errors)
      );
      console.log("Failed result: ");
      console.log(result);
      continue;
    }
    results.push(result);
  }

  return {
    ...data,
    results,
  };
}

export async function fetchSingleApiQuestion(id: number): Promise<ApiQuestion> {
  return await fetchAndValidate(
    `https://www.metaculus.com/api2/questions/${id}/`,
    validateQuestion
  );
}



---
File: /src/backend/platforms/metaculus/index.ts
---

import { saveQuestions } from "@/backend/dbUtils";
import { FetchedQuestion, Platform } from "@/backend/types";

import { average } from "../../../utils";
import { sleep } from "../../utils/sleep";
import {
  ApiCommon,
  ApiMultipleQuestions,
  ApiPredictable,
  ApiQuestion,
  fetchApiQuestions,
  fetchSingleApiQuestion,
} from "./api2";

const platformName = "metaculus";
const now = new Date().toISOString();
const SLEEP_TIME = 1000;

async function apiQuestionToFetchedQuestions(
  apiQuestion: ApiQuestion
): Promise<FetchedQuestion[]> {
  // one item can expand:
  // - to 0 questions if we don't want it;
  // - to 1 question if it's a simple forecast
  // - to multiple questions if it's a group (see https://github.com/quantified-uncertainty/metaforecast/pull/84 for details)

  const skip = (q: ApiPredictable): boolean => {
    if (q.publish_time > now || now > q.resolve_time) {
      return true;
    }

    // TODO - remove this check? we should just store everything and sort out the quality later
    if (q.prediction_count < 10) {
      return true;
    }

    return false;
  };

  function buildFetchedQuestion(
    q: ApiPredictable & ApiCommon
  ): Omit<FetchedQuestion, "url" | "description" | "title"> {
    const isBinary = q.possibilities.type === "binary";
    let options: FetchedQuestion["options"] = [];
    if (isBinary) {
      const probability = q.community_prediction?.full.q2;
      if (probability !== undefined) {
        options = [
          {
            name: "Yes",
            probability: probability,
            type: "PROBABILITY",
          },
          {
            name: "No",
            probability: 1 - probability,
            type: "PROBABILITY",
          },
        ];
      }
    }
    return {
      id: `${platformName}-${q.id}`,
      options,
      qualityindicators: {
        numforecasts: q.prediction_count,
      },
      extra: {
        resolution_data: {
          publish_time: apiQuestion.publish_time,
          resolution: apiQuestion.resolution,
          close_time: apiQuestion.close_time,
          resolve_time: apiQuestion.resolve_time,
        },
      },
    };
  }

  if (apiQuestion.type === "group") {
    await sleep(SLEEP_TIME);
    let apiQuestionDetails: ApiQuestion;
    try {
      apiQuestionDetails = await fetchSingleApiQuestion(apiQuestion.id);
    } catch (error) {
      console.log(error);
      return [];
    }

    if (apiQuestionDetails.type !== "group") {
      console.log("Error: expected `group` type");
      return [];
    }

    try {
      const result = (apiQuestionDetails.sub_questions || [])
        .filter((q) => !skip(q))
        .map((sq) => {
          const tmp = buildFetchedQuestion(sq);
          return {
            ...tmp,
            title: `${apiQuestion.title} (${sq.title})`,
            description: apiQuestionDetails.description ?? "",
            url: `https://www.metaculus.com${apiQuestion.page_url}?sub-question=${sq.id}`,
          };
        });
      return result;
    } catch (error) {
      console.log(error);
      return [];
    }
  } else if (apiQuestion.type === "forecast") {
    if (apiQuestion.group) {
      return []; // sub-question, should be handled on the group level
    }
    if (skip(apiQuestion)) {
      console.log(`- [Skipping]: ${apiQuestion.title}`);
      return [];
    }

    await sleep(SLEEP_TIME);
    try {
      const apiQuestionDetails = await fetchSingleApiQuestion(apiQuestion.id);
      const tmp = buildFetchedQuestion(apiQuestion);
      return [
        {
          ...tmp,
          title: apiQuestion.title,
          description: apiQuestionDetails.description ?? "",
          url: `https://www.metaculus.com${apiQuestion.page_url}`,
        },
      ];
    } catch (error) {
      console.log(error);
      return [];
    }
  } else {
    if (apiQuestion.type !== "claim") {
      // should never happen, since `discriminator` in JTD schema causes a strict runtime check
      console.log(
        `Unknown metaculus question type: ${apiQuestion.type}, skipping`
      );
    }
    return [];
  }
}

export const metaculus: Platform = {
  name: platformName,
  label: "Metaculus",
  color: "#006669",

  extendCliCommand(command) {
    command
      .command("fetch-one")
      .argument("<id>", "Fetch a single question by id")
      .action(async (idString) => {
        try {
          const id = Number(idString);
          const apiQuestion = await fetchSingleApiQuestion(id);
          const questions = await apiQuestionToFetchedQuestions(apiQuestion);
          console.log(questions);
          await saveQuestions({
            platform: metaculus,
            fetchedQuestions: questions,
          });
        } catch (error) {
          console.log(error);
        }
      });
  },

  async fetcher() {
    let allQuestions: FetchedQuestion[] = [];

    const debug = !!process.env["DEBUG"]!;

    let next: string | null = "https://www.metaculus.com/api2/questions/";
    let i = 1;
    while (next) {
      console.log(`\nQuery #${i} - ${next}`);

      await sleep(SLEEP_TIME);
      const apiQuestions: ApiMultipleQuestions = await fetchApiQuestions(next);
      const results = apiQuestions.results;
      let j = false;

      for (const result of results) {
        const questions = await apiQuestionToFetchedQuestions(result);

        for (const question of questions) {
          console.log(`- ${question.title}`);
          if ((!j && i % 20 === 0) || debug) {
            console.log(question);
            j = true;
          }
          allQuestions.push(question);
        }
      }

      next = apiQuestions.next;
      i += 1;
    }

    return { questions: allQuestions };
  },

  calculateStars(data) {
    const numforecasts = Number(data.qualityindicators.numforecasts);
    const nuno = () => (numforecasts > 300 ? 4 : numforecasts > 100 ? 3 : 2);
    const eli = () => 3;
    const misha = () => 3;
    const starsDecimal = average([nuno(), eli(), misha()]);
    const starsInteger = Math.round(starsDecimal);
    return starsInteger;
  },
};



---
File: /src/backend/platforms/polymarket/gamma.ts
---

import { z } from "zod";

// https://docs.polymarket.com/#gamma-markets-api
const gammaEndpoint = "https://gamma-api.polymarket.com";

export async function* fetchAllOpenMarkets() {
  let offset = 0;
  const limit = 500;

  const seen = new Set<string>();

  while (true) {
    const url = `${gammaEndpoint}/markets?offset=${offset}&limit=${limit}&closed=false`;
    console.log(`Fetching markets: ${url}`);
    const response = await fetch(url, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
      },
    });
    const data = await response.json();
    const listItems = z.array(z.unknown()).parse(data);
    for (let i = 0; i < listItems.length; i++) {
      const parsedMarket = marketSchema.safeParse(listItems[i]);
      if (parsedMarket.success) {
        const market = parsedMarket.data;
        if (seen.has(market.id)) {
          continue;
        }
        yield market;
        seen.add(market.id);
      } else {
        const error = parsedMarket.error;
        console.error(
          `Error parsing market[${i}]: ${error.issues.length} issues. First issue:\n${JSON.stringify(error.issues[0], null, 2)}`
        );
      }
    }
    if (listItems.length < limit) {
      break;
    }

    // TODO - add some overlap with deduplication, so that we don't miss any new markets
    offset += limit;
  }
}

const outcomeSchema = z.array(z.string());

const marketSchema = z.object({
  id: z.string(),
  question: z.string(),
  slug: z.string(),
  description: z.string(),
  outcomes: z.string().transform((s) => {
    const parsed = JSON.parse(s);
    return outcomeSchema.parse(parsed);
  }),
  outcomePrices: z
    .string()
    .optional()
    .transform((s) => {
      if (!s) return undefined;
      const parsed = JSON.parse(s);
      return outcomeSchema.parse(parsed);
    }),
  // this can be empty on newer markets, and I'm not sure how useful it is
  // note that this field is not always unique across markets, even if they don't belong to the same event.
  // Example:
  // - https://gamma-api.polymarket.com/markets?slug=nhl-pit-phi-2025-02-25
  // - https://gamma-api.polymarket.com/markets?slug=cbb-app-gaso-2025-02-25
  marketMakerAddress: z.string(),
  category: z.string().optional(),
  volumeNum: z.number().optional(),
  liquidityNum: z.number().optional(),
});

// TODO:
// startDate
// endDate
// category
// liquidity
// volumeNum
// liquidityNum
// volume24hr
// active
// closed



---
File: /src/backend/platforms/polymarket/index.ts
---

import { average } from "../../../utils";
import { FetchedQuestion, Platform } from "../../types";
import { fetchAllOpenMarkets } from "./gamma";

const platformName = "polymarket";

const verbose = false;

export const polymarket: Platform = {
  name: platformName,
  label: "Polymarket",
  color: "#00314e",

  async fetcher() {
    const questions: FetchedQuestion[] = [];

    for await (const market of fetchAllOpenMarkets()) {
      const metaforecast_id = `${platformName}-${market.id}`;

      if (market.outcomes.includes("Long")) {
        // some legacy workaround? I don't know what this checks for
        continue;
      }

      if (!market.outcomePrices || !market.volumeNum || !market.liquidityNum) {
        continue;
      }

      if (market.category === "Sports") {
        continue;
      }

      if (verbose) console.log(market);
      const tradevolume = market.volumeNum;
      const liquidity = market.liquidityNum;

      const options: FetchedQuestion["options"] = [];
      for (let i = 0; i < market.outcomes.length; i++) {
        options.push({
          name: String(market.outcomes[i]),
          probability: Number(market.outcomePrices[i]),
          type: "PROBABILITY",
        });
      }

      const result: FetchedQuestion = {
        id: metaforecast_id,
        title: market.question,
        url: "https://polymarket.com/market/" + market.slug,
        description: market.description,
        options,
        qualityindicators: {
          liquidity: liquidity,
          tradevolume: tradevolume.toFixed(2),
        },
        extra: {
          ...(market.marketMakerAddress && {
            address: market.marketMakerAddress,
          }),
        },
      };
      if (verbose) console.log(result);
      questions.push(result);
    }

    return { questions };
  },

  calculateStars(data) {
    const liquidity = Number(data.qualityindicators.liquidity) || 0;
    const volume = Number(data.qualityindicators.tradevolume) || 0;

    const nuno = () =>
      liquidity > 1000 && volume > 10000
        ? 4
        : liquidity > 500 && volume > 1000
          ? 3
          : 2;
    let starsDecimal = average([nuno()]);

    // Substract 1 star if probability is above 90% or below 10%
    if (
      data.options instanceof Array &&
      data.options[0] &&
      ((data.options[0].probability || 0) < 0.1 ||
        (data.options[0].probability || 0) > 0.9)
    ) {
      starsDecimal = starsDecimal - 1;
    }

    const starsInteger = Math.round(starsDecimal);
    return starsInteger;
  },
};



---
File: /src/backend/platforms/_example.ts
---

/* Imports */
import axios from "axios";

import { FetchedQuestion, Platform } from "../types";

/* Definitions */
const platformName = "example";
const endpoint = "https://example.com/";

/* Support functions */

async function fetchData() {
  let response = await axios({
    url: endpoint,
    method: "GET",
    headers: {
      "Content-Type": "text/html",
    },
  }).then((response) => response.data);
  // console.log(response)
  return response;
}

async function processPredictions(predictions: any[]) {
  const results = await predictions.map((prediction) => {
    const id = `${platformName}-${prediction.id}`;
    const probability = prediction.probability;
    const options: FetchedQuestion["options"] = [
      {
        name: "Yes",
        probability: probability,
        type: "PROBABILITY",
      },
      {
        name: "No",
        probability: 1 - probability,
        type: "PROBABILITY",
      },
    ];
    const result: FetchedQuestion = {
      id,
      title: prediction.title,
      url: "https://example.com",
      description: prediction.description,
      options,
      qualityindicators: {
        // other: prediction.otherx,
        // indicators: prediction.indicatorx,
      },
    };
    return result;
  });
  return results; //resultsProcessed
}

/* Body */

export const example: Platform = {
  name: platformName,
  label: "Example platform",
  color: "#ff0000",

  async fetcher() {
    const data = await fetchData();
    const results = await processPredictions(data); // somehow needed
    return { questions: results };
  },

  calculateStars(data) {
    return 2;
  },
};



---
File: /src/backend/platforms/betfair.ts
---

import axios from "axios";
import https from "https";

import { FetchedQuestion, Platform } from "../types";

/**
 * https://www.betfair.com
 *
 * We're interested only in the politics section, https://www.betfair.com/exchange/plus/en/politics-betting-2378961
 */

const platformName = "betfair";

/* Definitions */
const endpoint = process.env["SECRET_BETFAIR_ENDPOINT"]!;

/* Utilities */
function arraysEqual(a: string[], b: string[]) {
  if (a === b) return true;
  if (a == null || b == null) return false;
  if (a.length !== b.length) return false;

  // If you don't care about the order of the elements inside
  // the array, you should sort both arrays here.
  // Please note that calling sort on an array will modify that array.
  // you might want to clone your array first.
  for (let i = 0; i < a.length; ++i) {
    if (a[i] !== b[i]) return false;
  }
  return true;
}

function mergeRunners(runnerCatalog: any, runnerBook: any) {
  const keys = Object.keys(runnerCatalog);
  const result = [];
  for (let key of keys) {
    result.push({ ...runnerCatalog[key], ...runnerBook[key] });
  }
  return result;
}

/* Support functions */

async function fetchPredictions() {
  const agent = new https.Agent({
    rejectUnauthorized: false,
  });
  const response = await axios({
    url: endpoint,
    method: "GET",
    httpsAgent: agent,
  }).then((response) => response.data);

  return response;
}

async function whipIntoShape(data: any) {
  const catalogues = data.market_catalogues;
  const books = data.market_books;
  const keys1 = Object.keys(catalogues).sort();
  const keys2 = Object.keys(books).sort();
  // console.log(keys1)
  // console.log(keys2)
  const results = [];
  if (!arraysEqual(keys1, keys2)) {
    throw new Error(
      "Betfair: Error in endpoint; Betfair catalogues and books do not match"
    );
  } else {
    for (const key of keys1) {
      results.push({
        ...catalogues[key],
        ...books[key],
        options: mergeRunners(catalogues[key].runners, books[key].runners),
      });
    }
  }
  return results;
}

async function processPredictions(data: any) {
  const predictions = await whipIntoShape(data);

  const results: FetchedQuestion[] = predictions.map((prediction) => {
    const id = `${platformName}-${prediction.marketId}`;

    const normalizationFactor = prediction.options
      .filter(
        (option: any) => option.status == "ACTIVE" && option.totalMatched > 0
      )
      .map((option: any) => option.lastPriceTraded)
      .map((x: any) => 1 / x)
      .reduce((a: any, b: any) => a + b, 0);

    const options = prediction.options
      .filter(
        (option: any) => option.status == "ACTIVE" && option.totalMatched > 0
      )
      .map((option: any) => ({
        name: option.runnerName,
        probability:
          option.lastPriceTraded != 0
            ? 1 / option.lastPriceTraded / normalizationFactor
            : 0, // https://www.aceodds.com/bet-calculator/odds-converter.html
        type: "PROBABILITY",
      }));

    // console.log(prediction.options)

    const rules = prediction.description.rules
      .split("Regs</a>.")[1]
      .replace(/<br><br>/g, " ")
      .replace(/<br>/g, " ")
      .replace(/<b>/g, " ")
      .replace(/<\/b>/g, " ")
      .replace(/\n/g, " ")
      .trim();
    if (rules == undefined) {
      // console.log(prediction.description)
    }

    let title = rules.split("? ")[0] + "?";
    const description = rules.split("? ")[1].trim();
    if (title.includes("of the named")) {
      title = prediction.marketName + ": " + title;
    }
    const result: FetchedQuestion = {
      id,
      title,
      url: `https://www.betfair.com/exchange/plus/politics/market/${prediction.marketId}`,
      description,
      options,
      qualityindicators: {
        volume: prediction.totalMatched,
      },
    };
    return result;
  });
  return results;
}

export const betfair: Platform = {
  name: platformName,
  label: "Betfair",
  color: "#3d674a",

  async fetcher() {
    const data = await fetchPredictions();
    const results = await processPredictions(data);
    return { questions: results };
  },

  calculateStars(data) {
    const volume = data.qualityindicators.volume || 0;
    let starsDecimal = volume > 10000 ? 4 : volume > 1000 ? 3 : 2; // Nuño

    const firstOption = data.options[0];

    // Subtract 1 star if probability is above 90% or below 10%
    if (
      firstOption &&
      ((firstOption.probability || 0) < 0.1 ||
        (firstOption.probability || 0) > 0.9)
    ) {
      starsDecimal = starsDecimal - 1;
    }

    const starsInteger = Math.round(starsDecimal);
    return starsInteger;
  },
};



---
File: /src/backend/platforms/fantasyscotus.ts
---

/* Imports */
import axios from "axios";

import { FetchedQuestion, Platform } from "../types";

const platformName = "fantasyscotus";

/* Definitions */
const unixtime = new Date().getTime();
const endpoint = `https://fantasyscotus.net/case/list/?filterscount=0&groupscount=0&pagenum=0&pagesize=20&recordstartindex=0&recordendindex=12&_=${unixtime}`;

async function fetchData() {
  const response = await axios({
    method: "GET",
    url: endpoint,
    headers: {
      "User-Agent":
        "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:87.0) Gecko/20100101 Firefox/87.0",
      Accept: "application/json, text/javascript, */*; q=0.01",
      "Accept-Language": "en-US,en;q=0.5",
      "Content-Type": "application/x-www-form-urlencoded",
      "X-Requested-With": "XMLHttpRequest",
    },
    // referrer: "https://fantasyscotus.net/case/list/",
    // credentials: "omit",
    // mode: "cors",
  }).then((res) => res.data);

  return response;
}

async function getPredictionsData(caseUrl: string) {
  const newCaseUrl = `https://fantasyscotus.net/user-predictions${caseUrl}?filterscount=0&groupscount=0&sortdatafield=username&sortorder=asc&pagenum=0&pagesize=20&recordstartindex=0&recordendindex=20&_=${unixtime}`;

  const predictions = await axios({
    method: "GET",
    url: newCaseUrl,
    headers: {
      "User-Agent":
        "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:87.0) Gecko/20100101 Firefox/87.0",
      Accept: "application/json, text/javascript, */*; q=0.01",
      "Accept-Language": "en-US,en;q=0.5",
      "Content-Type": "application/x-www-form-urlencoded",
      "X-Requested-With": "XMLHttpRequest",
    },
    // referrer: newCaseUrl,
    // credentials: "include",
    // mode: "cors",
  }).then((res) => res.data);

  const predictionsAffirm = predictions.filter(
    (prediction: any) => prediction.percent_affirm > 50
  );

  return {
    numAffirm: predictionsAffirm.length,
    proportionAffirm: predictionsAffirm.length / predictions.length,
    numForecasts: predictions.length,
  };
}

async function processData(data: any) {
  const events = data.object_list;
  const historicalPercentageCorrect = data.stats.pcnt_correct;
  const historicalProbabilityCorrect =
    Number(historicalPercentageCorrect.replace("%", "")) / 100;

  const results: FetchedQuestion[] = [];
  for (let event of events) {
    if (event.accuracy == "") {
      let id = `${platformName}-${event.id}`;
      // if the thing hasn't already resolved
      let predictionData = await getPredictionsData(event.docket_url);
      let pAffirm = predictionData.proportionAffirm;
      //let trackRecord = event.prediction.includes("Affirm") ? historicalProbabilityCorrect : 1-historicalProbabilityCorrect
      let eventObject: FetchedQuestion = {
        id: id,
        title: `In ${event.short_name}, the SCOTUS will affirm the lower court's decision`,
        url: `https://fantasyscotus.net/user-predictions${event.docket_url}`,
        description: `${(pAffirm * 100).toFixed(2)}% (${
          predictionData.numAffirm
        } out of ${
          predictionData.numForecasts
        }) of FantasySCOTUS players predict that the lower court's decision will be affirmed. FantasySCOTUS overall predicts an outcome of ${
          event.prediction
        }. Historically, FantasySCOTUS has chosen the correct side ${historicalPercentageCorrect} of the time.`,
        options: [
          {
            name: "Yes",
            probability: pAffirm,
            type: "PROBABILITY",
          },
          {
            name: "No",
            probability: 1 - pAffirm,
            type: "PROBABILITY",
          },
        ],
        qualityindicators: {
          numforecasts: Number(predictionData.numForecasts),
        },
      };
      results.push(eventObject);
    }
  }

  return results;
}

export const fantasyscotus: Platform = {
  name: platformName,
  label: "FantasySCOTUS",
  color: "#231149",

  async fetcher() {
    const rawData = await fetchData();
    const questions = await processData(rawData);
    return { questions };
  },

  calculateStars() {
    return 2;
  },
};



---
File: /src/backend/platforms/foretold.ts
---

/* Imports */
import axios from "axios";

import { FetchedQuestion, Platform } from "../types";

/* Definitions */

const platformName = "foretold";

const graphQLendpoint = "https://api.foretold.io/graphql";
const highQualityCommunities = [
  "0104d8e8-07e4-464b-8b32-74ef22b49f21",
  "c47c6bc8-2c9b-4a83-9583-d1ed80a40fa2",
  "cf663021-f87f-4632-ad82-962d889a2d39",
  "47ff5c49-9c20-4f3d-bd57-1897c35cd42d",
  "b2412a1d-0aa4-4e37-a12a-0aca9e440a96",
];

/* Support functions */
async function fetchAllCommunityQuestions(communityId: string) {
  // TODO - fetch foretold graphql schema to type the result properly?
  // (should be doable with graphql-code-generator, why not)
  const response = await axios({
    url: graphQLendpoint,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: JSON.stringify({
      query: `
      query {
        measurables(
          channelId: "${communityId}",
          states: OPEN,
          first: 500
        ) {
          total
          edges {
            node {
              id
              name
              valueType
              measurementCount
              previousAggregate{
                value{
                  percentage
                }
              }
            }
          }
        }
      }
      `,
    }),
  })
    .then((res) => res.data)
    .then((res) => res.data.measurables.edges);

  return response as any[];
}

export const foretold: Platform = {
  name: platformName,
  label: "Foretold",
  color: "#62520b",

  async fetcher() {
    const results: FetchedQuestion[] = [];
    for (const community of highQualityCommunities) {
      let questions = await fetchAllCommunityQuestions(community);
      questions = questions.map((question) => question.node);
      questions = questions.filter((question) => question.previousAggregate); // Questions without any predictions
      questions.forEach((question) => {
        const id = `${platformName}-${question.id}`;

        let options: FetchedQuestion["options"] = [];
        if (question.valueType == "PERCENTAGE") {
          const probability = question.previousAggregate.value.percentage;
          options = [
            {
              name: "Yes",
              probability: probability / 100,
              type: "PROBABILITY",
            },
            {
              name: "No",
              probability: 1 - probability / 100,
              type: "PROBABILITY",
            },
          ];
        }

        const result: FetchedQuestion = {
          id,
          title: question.name,
          url: `https://www.foretold.io/c/${community}/m/${question.id}`,
          description: "",
          options,
          qualityindicators: {
            numforecasts: Math.floor(Number(question.measurementCount) / 2),
          },
          /*liquidity: liquidity.toFixed(2),
          tradevolume: tradevolume.toFixed(2),
          address: obj.address*/
        };
        // console.log(result)
        results.push(result);
      });
    }
    return { questions: results };
  },

  calculateStars() {
    return 2; // Nuño
  },
};



---
File: /src/backend/platforms/givewellopenphil.ts
---

import { Platform } from "../types";

/*
 * All code related to this was hopelessly outdated. Check out metaforecast repo history for more.
 *
 * Relevant links:
 * https://www.givewell.org/research/internal-forecasts
 * https://blog.givewell.org/2024/11/08/making-predictions-about-our-grants/
 * https://github.com/quantified-uncertainty/metaforecast/blob/master/input/givewellopenphil-urls.txt - old URLs that were used for this platform
 */
export const givewellopenphil: Platform = {
  name: "givewellopenphil",
  label: "GiveWell/OpenPhilanthropy",
  color: "#32407e",

  async fetcher() {
    return null;
  },

  calculateStars() {
    return 2; // Nuño
  },
};



---
File: /src/backend/platforms/goodjudgment.ts
---

/* Imports */
import axios from "axios";
import { tabletojson } from "tabletojson";

import { FetchedQuestion, Platform } from "../types";
import { hash } from "../utils/hash";

/* Definitions */
const platformName = "goodjudgment";
const endpoint = "https://goodjudgment.io/superforecasts/";

/* Body */
export const goodjudgment: Platform = {
  name: platformName,
  label: "Good Judgment",
  color: "#7d4f1b",

  async fetcher() {
    // Proxy fuckery
    // let proxy;
    /*
	 * try {
    proxy = await axios
      .get("http://pubproxy.com/api/proxy")
      .then((query) => query.data);
    console.log(proxy);
  } catch (error) {
    console.log("Proxy generation failed; using backup proxy instead");
    // hard-coded backup proxy
		*/
    // proxy = {
    // ip: ...
    // port: ...
    // };
    // // }
    // let agent = tunnel.httpsOverHttp({
    // proxy: {
    //     host: proxy.ip,
    //     port: proxy.port,
    // },
    // });

    const content = await axios
      .request({
        url: "https://goodjudgment.io/superforecasts/",
        method: "get",
        headers: {
          "User-Agent": "Firefox",
        },
        // agent,
        // port: 80,
      })
      .then((query) => query.data);

    // Processing
    let results: FetchedQuestion[] = [];
    let jsonTable = tabletojson.convert(content, { stripHtmlFromCells: false });
    jsonTable.shift(); // deletes first element
    jsonTable.pop(); // deletes last element

    for (let table of jsonTable) {
      let title = table[0]["0"].split("\t\t\t").splice(3)[0];
      if (title != undefined) {
        title = title.replaceAll("</a>", "");
        const id = `${platformName}-${hash(title)}`;
        const description = table
          .filter((row: any) => row["0"].includes("BACKGROUND:"))
          .map((row: any) => row["0"])
          .map((text: any) =>
            text
              .split("BACKGROUND:")[1]
              .split("Examples of Superforecaster")[0]
              .split("AT A GLANCE")[0]
              .replaceAll("\n\n", "\n")
              .split("\n")
              .slice(3)
              .join(" ")
              .replaceAll("      ", "")
              .replaceAll("<br> ", "")
          )[0];
        const options = table
          .filter((row: any) => "4" in row)
          .map((row: any) => ({
            name: row["2"]
              .split('<span class="qTitle">')[1]
              .replace("</span>", ""),
            probability: Number(row["3"].split("%")[0]) / 100,
            type: "PROBABILITY",
          }));
        let analysis = table.filter((row: any) =>
          row[0] ? row[0].toLowerCase().includes("commentary") : false
        );
        // "Examples of Superforecaster Commentary" / Analysis
        // The following is necessary twice, because we want to check if there is an empty list, and then get the first element of the first element of the list.
        analysis = analysis ? analysis[0] : "";
        analysis = analysis ? analysis[0] : "";
        // not a duplicate
        // console.log(analysis)
        let standardObj: FetchedQuestion = {
          id,
          title,
          url: endpoint,
          description,
          options,
          qualityindicators: {},
          extra: {
            superforecastercommentary: analysis || "",
          },
        };
        results.push(standardObj);
      }
    }

    console.log(
      "Note that failing is not unexpected; see utils/pullSuperforecastsManually.sh/js"
    );

    return { questions: results };
  },

  calculateStars() {
    return 4; // Nuño
  },
};



---
File: /src/backend/platforms/goodjudgmentopen.ts
---

/* Imports */
import axios from "axios";

import { FullQuestionOption } from "../../common/types";
import { average } from "../../utils";
import { Platform } from "../types";
import { applyIfSecretExists } from "../utils/getSecrets";
import { sleep } from "../utils/sleep";
import toMarkdown from "../utils/toMarkdown";

/* Definitions */
const platformName = "goodjudgmentopen";

const htmlEndPoint = "https://www.gjopen.com/questions?page=";
const annoyingPromptUrls = [
  "https://www.gjopen.com/questions/1933-what-forecasting-questions-should-we-ask-what-questions-would-you-like-to-forecast-on-gjopen",
  "https://www.gjopen.com/questions/1779-are-there-any-forecasting-tips-tricks-and-experiences-you-would-like-to-share-and-or-discuss-with-your-fellow-forecasters",
  "https://www.gjopen.com/questions/2246-are-there-any-forecasting-tips-tricks-and-experiences-you-would-like-to-share-and-or-discuss-with-your-fellow-forecasters-2022-thread",
  "https://www.gjopen.com/questions/2237-what-forecasting-questions-should-we-ask-what-questions-would-you-like-to-forecast-on-gjopen",
  "https://www.gjopen.com/questions/2437-what-forecasting-questions-should-we-ask-what-questions-would-you-like-to-forecast-on-gjopen",
];
const DEBUG_MODE: "on" | "off" = "off"; // "on"
const id = () => 0;

/* Support functions */

function cleanDescription(text: string) {
  let md = toMarkdown(text);
  let result = md.replaceAll("---", "-").replaceAll("  ", " ");
  return result;
}

async function fetchPage(page: number, cookie: string) {
  const response: string = await axios({
    url: htmlEndPoint + page,
    method: "GET",
    headers: {
      Cookie: cookie,
    },
  }).then((res) => res.data);
  // console.log(response)
  return response;
}

async function fetchStats(questionUrl: string, cookie: string) {
  let response: string = await axios({
    url: questionUrl + "/stats",
    method: "GET",
    headers: {
      "Content-Type": "text/html",
      Cookie: cookie,
      Referer: questionUrl,
    },
  }).then((res) => res.data);

  if (response.includes("Sign up or sign in to forecast")) {
    throw Error("Not logged in");
  }
  // Init
  let options: FullQuestionOption[] = [];

  // Parse the embedded json
  let htmlElements = response.split("\n");
  let jsonLines = htmlElements.filter((element) =>
    element.includes("data-react-props")
  );
  let embeddedJsons = jsonLines.map((jsonLine, i) => {
    let innerJSONasHTML = jsonLine.split('data-react-props="')[1].split('"')[0];
    let json = JSON.parse(innerJSONasHTML.replaceAll("&quot;", '"'));
    return json;
  });
  let firstEmbeddedJson = embeddedJsons[0];
  let title = firstEmbeddedJson.question.name;
  let description = cleanDescription(firstEmbeddedJson.question.description);
  let comments_count = firstEmbeddedJson.question.comments_count;
  let numforecasters = firstEmbeddedJson.question.predictors_count;
  let numforecasts = firstEmbeddedJson.question.prediction_sets_count;
  let questionType = firstEmbeddedJson.question.type;
  if (
    questionType.includes("Binary") ||
    questionType.includes("NonExclusiveOpinionPoolQuestion") ||
    questionType.includes("Forecast::Question") ||
    !questionType.includes("Forecast::MultiTimePeriodQuestion")
  ) {
    options = firstEmbeddedJson.question.answers.map((answer: any) => ({
      name: answer.name,
      probability: answer.normalized_probability,
      type: "PROBABILITY",
    }));
    if (options.length == 1 && options[0].name == "Yes") {
      let probabilityNo =
        options[0].probability > 1
          ? 1 - options[0].probability / 100
          : 1 - options[0].probability;
      options.push({
        name: "No",
        probability: probabilityNo,
        type: "PROBABILITY",
      });
    }
  }
  let result = {
    description: description,
    options: options,
    qualityindicators: {
      numforecasts: Number(numforecasts),
      numforecasters: Number(numforecasters),
      comments_count: Number(comments_count),
    },
  };
  // console.log(JSON.stringify(result, null, 4));
  return result;
}

function isSignedIn(html: string) {
  let isSignedInBool = !(
    html.includes("You need to sign in or sign up before continuing") ||
    html.includes("Sign up")
  );
  // console.log(html)
  if (!isSignedInBool) {
    console.log("Error: Not signed in.");
  }
  console.log(`is signed in? ${isSignedInBool ? "yes" : "no"}`);
  return isSignedInBool;
}

function reachedEnd(html: string) {
  let reachedEndBool =
    html.includes("No questions match your filter") ||
    !html.includes("Good Judgment");
  if (reachedEndBool) {
    // console.log(html)
  }
  console.log(`Reached end? ${reachedEndBool}`);
  return reachedEndBool;
}

/* Body */

async function goodjudgmentopen_inner(cookie: string) {
  let i = 1;
  let response = await fetchPage(i, cookie);

  let results = [];
  let init = Date.now();
  // console.log("Downloading... This might take a couple of minutes. Results will be shown.")
  console.log("Page #1");
  while (!reachedEnd(response) && isSignedIn(response)) {
    let htmlLines = response.split("\n");
    DEBUG_MODE == "on" ? htmlLines.forEach((line) => console.log(line)) : id();
    let h5elements = htmlLines.filter((str) => str.includes("<h5> <a href="));
    DEBUG_MODE == "on" ? console.log(h5elements) : id();
    let j = 0;
    for (let h5element of h5elements) {
      let h5elementSplit = h5element.split('"><span>');
      let url = h5elementSplit[0].split('<a href="')[1];
      if (!annoyingPromptUrls.includes(url)) {
        let title = h5elementSplit[1].replace("</span></a></h5>", "");
        await sleep(1000 + Math.random() * 1000); // don't be as noticeable
        try {
          let moreinfo = await fetchStats(url, cookie);
          /*if (moreinfo.isbinary) {
            if (! moreinfo.crowdpercentage) { // then request again.
              moreinfo = await fetchStats(url, cookie);
            }
          }*/
          let questionNumRegex = new RegExp("questions/([0-9]+)");
          const questionNumMatch = url.match(questionNumRegex);
          if (!questionNumMatch) {
            throw new Error(`Couldn't find question num in ${url}`);
          }
          let questionNum = questionNumMatch[1];
          let id = `${platformName}-${questionNum}`;
          let question = {
            id: id,
            title: title,
            url: url,
            platform: platformName,
            ...moreinfo,
          };
          if (j % 30 == 0 || DEBUG_MODE == "on") {
            console.log(`Page #${i}`);
            console.log(question);
          } else {
            console.log(question.title);
          }
          // console.log(question)
          results.push(question);
        } catch (error) {
          console.log(error);
          console.log(
            `We encountered some error when fetching the URL: ${url}, so it won't appear on the final json`
          );
        }
      }
      j = j + 1;
    }
    i = i + 1;
    // console.log("Sleeping for 5secs so as to not be as noticeable to the gjopen servers")
    await sleep(5000 + Math.random() * 1000); // don't be a dick to gjopen server

    try {
      response = await fetchPage(i, cookie);
    } catch (error) {
      console.log(error);
      console.log(
        `We encountered some error when fetching page #${i}, so it won't appear on the final json`
      );
    }
  }

  if (results.length === 0) {
    console.log("Not updating results, as process was not signed in");
    return;
  }

  let end = Date.now();
  let difference = end - init;
  console.log(
    `Took ${difference / 1000} seconds, or ${difference / (1000 * 60)} minutes.`
  );

  return results;
}

export const goodjudgmentopen: Platform = {
  name: platformName,
  label: "Good Judgment Open",
  color: "#002455",

  async fetcher() {
    let cookie = process.env["GOODJUDGMENTOPENCOOKIE"]!;
    const questions = await applyIfSecretExists(cookie, goodjudgmentopen_inner);
    if (!questions) {
      return null;
    }
    return { questions };
  },

  calculateStars(data) {
    const minProbability = Math.min(
      ...data.options.map((option) => option.probability || 0)
    );
    const maxProbability = Math.max(
      ...data.options.map((option) => option.probability || 0)
    );

    const nuno = () =>
      Number(data.qualityindicators.numforecasts || 0) > 100 ? 3 : 2;
    const eli = () => 3;
    const misha = () =>
      minProbability > 0.1 || maxProbability < 0.9 ? 3.1 : 2.5;

    let starsDecimal = average([nuno(), eli(), misha()]);
    let starsInteger = Math.round(starsDecimal);
    return starsInteger;
  },
};



---
File: /src/backend/platforms/guesstimate.ts
---

import axios from "axios";

import { Question } from "@quri/metaforecast-db";

import { prepareQuestion, upsertSingleQuestion } from "../dbUtils";
import { FetchedQuestion, Platform } from "../types";
import { ElasticQuestion, questionToElasticDocument } from "../utils/elastic";

/* Definitions */
const searchEndpoint =
  "https://m629r9ugsg-dsn.algolia.net/1/indexes/Space_production/query?x-algolia-agent=Algolia%20for%20vanilla%20JavaScript%203.32.1&x-algolia-application-id=M629R9UGSG&x-algolia-api-key=4e893740a2bd467a96c8bfcf95b2809c";

const apiEndpoint = "https://api.getguesstimate.com";

function modelToQuestion(model: any): ReturnType<typeof prepareQuestion> {
  const { description } = model;
  // const description = model.description
  //   ? model.description.replace(/\n/g, " ").replace(/  /g, " ")
  //   : "";
  // const timestamp = parseISO(model.created_at);
  const fq: FetchedQuestion = {
    id: `guesstimate-${model.id}`,
    title: model.name,
    url: `https://www.getguesstimate.com/models/${model.id}`,
    // timestamp,
    description: description || "",
    options: [],
    qualityindicators: {
      numforecasts: 1,
      numforecasters: 1,
    },
    extra: {
      visualization: model.big_screenshot,
    },
    // ranking: 10 * (index + 1) - 0.5, //(model._rankingInfo - 1*index)// hack
  };
  const q = prepareQuestion(fq, guesstimate);
  return q;
}

class Guesstimate implements Platform {
  name = "guesstimate";
  label = "Guesstimate";
  color = "#223900";

  calculateStars(q: FetchedQuestion) {
    return q.description?.length > 250 ? 2 : 1;
  }

  // extra, guesstimate-specific methods
  async fetchQuestion(id: number): Promise<Question> {
    const response = await axios({ url: `${apiEndpoint}/spaces/${id}` });
    const q = modelToQuestion(response.data);
    return await upsertSingleQuestion(q);
  }

  async search(query: string): Promise<ElasticQuestion[]> {
    const response = await axios({
      url: searchEndpoint,
      headers: {
        Accept: "application/json",
        "Content-Type": "application/x-www-form-urlencoded",
      },
      data: `{"params":"query=${query.replace(
        / /g,
        "%20"
      )}&hitsPerPage=20&page=0&getRankingInfo=true"}`,
      method: "POST",
    });

    const models: any[] = response.data.hits;
    const mappedModels: ElasticQuestion[] = models.map((model) => {
      const q = modelToQuestion(model);
      return questionToElasticDocument({
        ...q,
        fetched: new Date(),
        firstSeen: new Date(),
      });
    });

    // filter for duplicates. Surprisingly common.
    const uniqueTitles: string[] = [];
    const uniqueModels: ElasticQuestion[] = [];
    for (let model of mappedModels) {
      if (
        !uniqueTitles.includes(model.title) &&
        !model.title.includes("copy")
      ) {
        uniqueModels.push(model);
        uniqueTitles.push(model.title);
      }
    }

    return uniqueModels;
  }
}

export const guesstimate = new Guesstimate();



---
File: /src/backend/platforms/infer.ts
---

/* Imports */
import axios from "axios";

import { FullQuestionOption } from "../../common/types";
import { FetchedQuestion, Platform } from "../types";
import { applyIfSecretExists } from "../utils/getSecrets";
import { measureTime } from "../utils/measureTime";
import { sleep } from "../utils/sleep";
import toMarkdown from "../utils/toMarkdown";

/* Definitions */
const platformName = "infer";
const htmlEndPoint = "https://www.infer-pub.com/questions";
const DEBUG_MODE: "on" | "off" = "off"; // "off"
const SLEEP_TIME_RANDOM = 7000; // miliseconds
const SLEEP_TIME_EXTRA = 2000;

/* Support functions */

function cleanDescription(text: string) {
  let md = toMarkdown(text);
  let result = md.replaceAll("---", "-").replaceAll("  ", " ");
  return result;
}

async function fetchPage(page: number, cookie: string) {
  console.log(`Page #${page}`);
  if (page == 1) {
    cookie = cookie.split(";")[0]; // Interesting that it otherwise doesn't work :(
  }
  let urlEndpoint = `${htmlEndPoint}/?page=${page}`;
  console.log(urlEndpoint);
  const response: string = await axios({
    url: urlEndpoint,
    method: "GET",
    headers: {
      "Content-Type": "text/html",
      Cookie: cookie,
    },
  }).then((res) => res.data);
  // console.log(response)
  return response;
}

async function fetchStats(questionUrl: string, cookie: string) {
  let response: string = await axios({
    url: questionUrl + "/stats",
    method: "GET",
    headers: {
      "Content-Type": "text/html",
      Cookie: cookie,
      Referer: questionUrl,
    },
  }).then((res) => res.data);

  if (response.includes("Sign up or sign in to forecast")) {
    throw Error("Not logged in");
  }
  // Init
  let options: FullQuestionOption[] = [];

  // Parse the embedded json
  let htmlElements = response.split("\n");
  let jsonLines = htmlElements.filter((element) =>
    element.includes("data-react-props")
  );
  let embeddedJsons = jsonLines.map((jsonLine, i) => {
    let innerJSONasHTML = jsonLine.split('data-react-props="')[1].split('"')[0];
    let json = JSON.parse(innerJSONasHTML.replaceAll("&quot;", '"'));
    return json;
  });
  let firstEmbeddedJson = embeddedJsons[0];
  let title = firstEmbeddedJson.question.name;
  let description = cleanDescription(firstEmbeddedJson.question.description);
  let comments_count = firstEmbeddedJson.question.comments_count;
  let numforecasters = firstEmbeddedJson.question.predictors_count;
  let numforecasts = firstEmbeddedJson.question.prediction_sets_count;
  let questionType = firstEmbeddedJson.question.type;
  if (
    questionType.includes("Binary") ||
    questionType.includes("NonExclusiveOpinionPoolQuestion") ||
    questionType.includes("Forecast::Question") ||
    !questionType.includes("Forecast::MultiTimePeriodQuestion")
  ) {
    options = firstEmbeddedJson.question.answers.map((answer: any) => ({
      name: answer.name,
      probability: answer.normalized_probability,
      type: "PROBABILITY",
    }));
    if (options.length == 1 && options[0].name == "Yes") {
      let probabilityNo =
        options[0].probability > 1
          ? 1 - options[0].probability / 100
          : 1 - options[0].probability;
      options.push({
        name: "No",
        probability: probabilityNo,
        type: "PROBABILITY",
      });
    }
  }
  let result = {
    description: description,
    options: options,
    qualityindicators: {
      numforecasts: Number(numforecasts),
      numforecasters: Number(numforecasters),
      comments_count: Number(comments_count),
    },
  };
  // console.log(JSON.stringify(result, null, 4));
  return result;
}

function isSignedIn(html: string) {
  let isSignedInBool = !(
    html.includes("You need to sign in or sign up before continuing") ||
    html.includes("Sign up")
  );
  if (!isSignedInBool) {
    console.log("Error: Not signed in.");
  }
  console.log(`Signed in? ${isSignedInBool ? "yes" : "no"}`);
  return isSignedInBool;
}

function reachedEnd(html: string) {
  let reachedEndBool =
    html.includes("No questions match your filter") || !html.includes("infer");
  if (reachedEndBool) {
    //console.log(html)
  }
  console.log(`Reached end? ${reachedEndBool ? "yes" : "no"}`);
  return reachedEndBool;
}

/* Body */

async function infer_inner(cookie: string) {
  let i = 1;
  let response = await fetchPage(i, cookie);
  let results: FetchedQuestion[] = [];

  await measureTime(async () => {
    // console.log("Downloading... This might take a couple of minutes. Results will be shown.")
    while (!reachedEnd(response) && isSignedIn(response)) {
      let htmlLines = response.split("\n");
      // let h4elements = htmlLines.filter(str => str.includes("<h5> <a href=") || str.includes("<h4> <a href="))
      let questionHrefs = htmlLines.filter((str) =>
        str.includes("https://www.infer-pub.com/questions/")
      );
      // console.log(questionHrefs)

      if (process.env["DEBUG_MODE"] == "on" || DEBUG_MODE == "on") {
        console.log("questionHrefs: ");
        console.log(questionHrefs);
      }

      for (let questionHref of questionHrefs) {
        let elementSplit = questionHref.split('"><span>');
        let url = elementSplit[0].split('<a href="')[1];
        let title = elementSplit[1]
          .replace("</h4>", "")
          .replace("</h5>", "")
          .replace("</span></a>", "");
        await sleep(Math.random() * SLEEP_TIME_RANDOM + SLEEP_TIME_EXTRA); // don't be as noticeable

        try {
          const moreinfo = await fetchStats(url, cookie);
          const questionNumRegex = new RegExp("questions/([0-9]+)");
          const questionNumMatch = url.match(questionNumRegex);
          if (!questionNumMatch) {
            throw new Error(`Couldn't find question num in ${url}`);
          }
          let questionNum = questionNumMatch[1];
          const id = `${platformName}-${questionNum}`;
          let question: FetchedQuestion = {
            id,
            title,
            url,
            ...moreinfo,
          };
          console.log(JSON.stringify(question, null, 4));
          if (
            i % 30 == 0 &&
            !(process.env["DEBUG_MODE"] == "on" || DEBUG_MODE == "on")
          ) {
            console.log(`Page #${i}`);
            console.log(question);
          }
          results.push(question);
          if (process.env["DEBUG_MODE"] == "on" || DEBUG_MODE == "on") {
            console.log(url);
            console.log(question);
          }
        } catch (error) {
          console.log(error);
          console.log(
            `We encountered some error when fetching the URL: ${url}, so it won't appear on the final json`
          );
        }
      }

      i++;

      console.log(
        "Sleeping for ~5secs so as to not be as noticeable to the infer servers"
      );
      await sleep(Math.random() * SLEEP_TIME_RANDOM + SLEEP_TIME_EXTRA); // don't be as noticeable

      try {
        response = await fetchPage(i, cookie);
      } catch (error) {
        console.log(error);
        console.log(
          `The program encountered some error when fetching page #${i}, so it won't appear on the final json. It is possible that this page wasn't actually a prediction question pages`
        );
      }
    }
  });

  if (results.length === 0) {
    console.log("Not updating results, as process was not signed in");
    return;
  }
  return results;
}

export const infer: Platform = {
  name: platformName,
  label: "Infer",
  color: "#223900",
  async fetcher() {
    const cookie = process.env["INFER_COOKIE"]!;
    const questions = await applyIfSecretExists(cookie, infer_inner);
    if (!questions) {
      return null;
    }
    return { questions };
  },
  calculateStars() {
    return 2; // Nuño
  },
};



---
File: /src/backend/platforms/insight.ts
---

import { Platform } from "../types";

/**
 * https://insightprediction.com/
 *
 * Legacy platform. I've removed all code for not, not worth maintaining, volume is too low.
 *
 * Legacy code is in https://github.com/quantified-uncertainty/metaforecast/blob/15ea265f6d73960c2b5d3f9f1298bfee63164c67/src/backend/platforms/insight.ts
 */
export const insight: Platform = {
  name: "insight",
  label: "Insight Prediction",
  color: "#ff0000",

  calculateStars: () => 1,
};



---
File: /src/backend/platforms/kalshi.ts
---

import api from "api";

import { Platform } from "../types";

/**
 * https://kalshi.com
 *
 * Broken/disabled, FIXME.
 */

const kalshi_api = api("@trading-api/v2.0#13mtbs10lc863irx");

/* Definitions */
const platformName = "kalshi";
let jsonEndpoint = "https://trading-api.kalshi.com/v2";

async function fetchAllMarkets() {
  try {
    let response = await kalshi_api.login({
      email: process.env["KALSHI_EMAIL"]!,
      password: process.env["KALSHI_PASSWORD"]!,
    });
    console.log(response.data);
    let exchange_status = await kalshi_api.getExchangeStatus();
    console.log(exchange_status.data);

    // kalshi_api.auth(process.env.KALSHI_EMAIL, process.env.KALSHI_PASSWORD);
    kalshi_api.auth(response.member_id, response.token);
    /*
     */
    let market_params = {
      limit: "100",
      cursor: null,
      event_ticker: null,
      series_ticker: null,
      max_close_ts: null,
      min_close_ts: null,
      status: null,
      tickers: null,
    };
    // let markets = await kalshi_api.getMarkets(market_params).then(({data: any}) => console.log(data))
    // console.log(markets)
  } catch (error) {
    console.log(error);
  }

  return 1;
}

/*
async function fetchAllMarkets() {
  let response = await axios
    .get(jsonEndpoint)
    .then((response) => response.data.markets);

  return response;
}

async function processMarkets(markets: any[]) {
  let dateNow = new Date().toISOString();
  // console.log(markets)
  markets = markets.filter((market) => market.close_date > dateNow);
  let results = await markets.map((market) => {
    const probability = market.last_price / 100;
    const options: FetchedQuestion["options"] = [
      {
        name: "Yes",
        probability: probability,
        type: "PROBABILITY",
      },
      {
        name: "No",
        probability: 1 - probability,
        type: "PROBABILITY",
      },
    ];
    const id = `${platformName}-${market.id}`;
    const result: FetchedQuestion = {
      id,
      title: market.title.replaceAll("*", ""),
      url: `https://kalshi.com/markets/${market.ticker_name}`,
      description: `${market.settle_details}. The resolution source is: ${market.ranged_group_name} (${market.settle_source_url})`,
      options,
      qualityindicators: {
        yes_bid: market.yes_bid,
        yes_ask: market.yes_ask,
        spread: Math.abs(market.yes_bid - market.yes_ask),
        shares_volume: market.volume, // Assuming that half of all buys are for yes and half for no, which is a big if.
        // "open_interest": market.open_interest, also in shares
      },
      extra: {
        open_interest: market.open_interest,
      },
    };
    return result;
  });

  console.log([...new Set(results.map((result) => result.title))]);
  console.log(
    "Number of unique questions: ",
    [...new Set(results.map((result) => result.title))].length
  );

  return results;
}
*/

export const kalshi: Platform = {
  name: platformName,
  label: "Kalshi",
  color: "#615691",

  fetcher: async function () {
    // let markets = await fetchAllMarkets();
    // console.log(markets)
    return { questions: [] };
  },

  calculateStars(data) {
    const nuno = () =>
      ((data.extra as any)?.open_interest || 0) > 500 &&
      data.qualityindicators.shares_volume > 10000
        ? 4
        : data.qualityindicators.shares_volume > 2000
          ? 3
          : 2;
    let starsDecimal = nuno();

    // Substract 1 star if probability is above 90% or below 10%
    if (
      data.options instanceof Array &&
      data.options[0] &&
      ((data.options[0].probability || 0) < 0.1 ||
        (data.options[0].probability || 0) > 0.9)
    ) {
      starsDecimal = starsDecimal - 1;
    }

    const starsInteger = Math.round(starsDecimal);
    return starsInteger;
  },
};



---
File: /src/backend/platforms/predictit.ts
---

import axios from "axios";

import { average } from "../../utils";
import { FetchedQuestion, Platform } from "../types";
import { sleep } from "../utils/sleep";
import toMarkdown from "../utils/toMarkdown";

const platformName = "predictit";

/* Support functions */
async function fetchmarkets(): Promise<any[]> {
  const response = await axios({
    method: "get",
    url: "https://www.predictit.org/api/marketdata/all/",
  });
  const openMarkets = response.data.markets.filter(
    (market: any) => market.status == "Open"
  );
  return openMarkets;
}

async function fetchMarketRules(market_id: string | number) {
  const response = await axios({
    method: "get",
    url: "https://www.predictit.org/api/Market/" + market_id,
  });
  return response.data.rule;
}

async function fetchMarketVolumes() {
  const response = await axios({
    method: "get",
    url: "https://predictit-f497e.firebaseio.com/marketStats.json",
  });
  return response.data;
}

export const predictit: Platform = {
  name: platformName,
  label: "PredictIt",
  color: "#460c00",
  async fetcher() {
    let markets = await fetchmarkets();
    const marketVolumes = await fetchMarketVolumes();

    markets = markets.map((market) => ({
      ...market,
      TotalSharesTraded: marketVolumes[market.id]["TotalSharesTraded"],
    }));

    const results: FetchedQuestion[] = [];
    for (const market of markets) {
      const id = `${platformName}-${market.id}`;
      await sleep(3000 * (1 + Math.random()));
      const descriptionRaw = await fetchMarketRules(market.id);
      const descriptionProcessed1 = toMarkdown(descriptionRaw);
      const description = descriptionProcessed1;
      const shares_volume = market["TotalSharesTraded"];

      // let isbinary = market.contracts.length == 1;
      // let percentageFormatted = isbinary ? Number(Number(market.contracts[0].lastTradePrice) * 100).toFixed(0) + "%" : "none"

      let options: FetchedQuestion["options"] = (market.contracts as any[]).map(
        (contract) => ({
          name: String(contract.name),
          probability: Number(contract.lastTradePrice),
          type: "PROBABILITY",
        })
      );
      const totalValue = options
        .map((element: any) => Number(element.probability))
        .reduce((a, b) => a + b, 0);

      if (options.length !== 1 && totalValue > 1) {
        options = options.map((element) => ({
          ...element,
          probability: Number(element.probability) / totalValue,
        }));
      } else if (options.length == 1) {
        const option = options[0];
        const probability = option.probability;
        options = [
          {
            name: "Yes",
            probability: probability,
            type: "PROBABILITY",
          },
          {
            name: "No",
            probability: 1 - (probability || 0),
            type: "PROBABILITY",
          },
        ];
      }

      const obj: FetchedQuestion = {
        id,
        title: market["name"],
        url: market.url,
        description,
        options,
        qualityindicators: {
          shares_volume,
        },
      };
      results.push(obj);
    }

    return { questions: results };
  },

  calculateStars() {
    const nuno = () => 3;
    const eli = () => 3.5;
    const misha = () => 2.5;
    const starsDecimal = average([nuno(), eli(), misha()]);
    const starsInteger = Math.round(starsDecimal);
    return starsInteger;
  },
};



---
File: /src/backend/platforms/rootclaim.ts
---

import axios from "axios";
import { JSDOM } from "jsdom";

import { FetchedQuestion, Platform } from "../types";
import toMarkdown from "../utils/toMarkdown";

const platformName = "rootclaim";
const jsonEndpoint =
  "https://live-rootclaim-backend.herokuapp.com/analysis/public-list?limit=1000&offset=0";

async function fetchAllRootclaims() {
  console.log(`Fetching ${jsonEndpoint}`);
  const response = await axios
    .get(jsonEndpoint)
    .then((response) => response.data);

  const claims = response.result.main_page_stories;
  if (typeof claims !== "object") {
    throw new Error("Expected result.main_page_stories field in API response");
  }
  return claims;
}

async function fetchDescription(url: string, isclaim: boolean) {
  console.log(`Fetching description for ${url}`);
  const response = await axios.get(url).then((response) => response.data);

  const { document } = new JSDOM(response).window;
  const nextDataEl = document.querySelector("#__NEXT_DATA__");
  if (!nextDataEl) {
    throw new Error(`Couldn't find __NEXT_DATA__ for ${url}`);
  }

  const data = JSON.parse(nextDataEl.innerHTML);
  const mainData = data?.props?.pageProps?.initialReduxState?.main;
  const info = isclaim
    ? mainData?.claim?.background
    : mainData?.analise?.background_info;

  if (!info) {
    throw new Error(`Couldn't find description for page ${url}`);
  }
  return info;
}

export const rootclaim: Platform = {
  name: platformName,
  label: "Rootclaim",
  color: "#0d1624",

  async fetcher() {
    const claims = await fetchAllRootclaims();
    const questions: FetchedQuestion[] = [];

    for (const claim of claims) {
      const id = `${platformName}-${claim.slug.toLowerCase()}`;

      const options: FetchedQuestion["options"] = [];
      for (const scenario of claim.scenarios) {
        options.push({
          name: toMarkdown(scenario.name || scenario.text)
            .replace("\n", "")
            .replace("&#39;", "'"),
          probability: scenario.net_prob / 100,
          type: "PROBABILITY",
        });
      }

      const claimUrlPath = claim.isclaim ? "claims" : "analysis";
      const url = `https://www.rootclaim.com/${claimUrlPath}/${claim.slug}`;

      const description = await fetchDescription(url, claim.isclaim);

      const obj: FetchedQuestion = {
        id,
        title: toMarkdown(claim.question).replace("\n", ""),
        url,
        description: toMarkdown(description).replace("&#39;", "'"),
        options,
        qualityindicators: {
          numforecasts: 1,
        },
      };
      questions.push(obj);
    }
    return { questions };
  },

  calculateStars() {
    return 4; // Nuño
  },
};



---
File: /src/backend/platforms/smarkets.ts
---

import axios from "axios";

import { QuestionOption } from "../../common/types";
import { saveQuestions } from "../dbUtils";
import { FetchedQuestion, Platform } from "../types";

/* Definitions */
const platformName = "smarkets";
const apiEndpoint = "https://api.smarkets.com/v3"; // documented at https://docs.smarkets.com/

type Context = {
  verbose: boolean;
};

/* Support functions */

async function fetchEvents(ctx: Context) {
  let queryString =
    "?state=new&state=upcoming&state=live&type_domain=politics&type_scope=single_event&with_new_type=true&sort=id&limit=50";

  let events = [];
  while (queryString) {
    const data = await axios({
      url: `${apiEndpoint}/events/${queryString}`,
      method: "GET",
    }).then((res) => res.data);

    events.push(...data.events);
    queryString = data.pagination.next_page;
  }
  ctx.verbose && console.log(events);

  return events;
}

async function fetchSingleEvent(id: string, ctx: Context) {
  const events = await fetchEvents(ctx);
  const event = events.find((event) => event.id === id);
  if (!event) {
    throw new Error(`Event ${id} not found`);
  }
  return event;
}

async function fetchMarkets(eventId: string) {
  const response = await axios({
    url: `${apiEndpoint}/events/${eventId}/markets/`,
    method: "GET",
  })
    .then((res) => res.data)
    .then((res) => res.markets);
  return response;
}

async function fetchContracts(marketId: string, ctx: Context) {
  const response = await axios({
    url: `${apiEndpoint}/markets/${marketId}/contracts/?include_hidden=true`,
    method: "GET",
  }).then((res) => res.data);
  ctx.verbose && console.log(response);

  if (!(response.contracts instanceof Array)) {
    throw new Error("Invalid response while fetching contracts");
  }
  return response.contracts as any[];
}

async function fetchPrices(marketId: string, ctx: Context) {
  const response = await axios({
    url: `https://api.smarkets.com/v3/markets/${marketId}/last_executed_prices/`,
    method: "GET",
  }).then((res) => res.data);
  ctx.verbose && console.log(response);
  if (!response.last_executed_prices) {
    throw new Error("Invalid response while fetching prices");
  }
  return response.last_executed_prices;
}

async function processEventMarkets(event: any, ctx: Context) {
  ctx.verbose && console.log(Date.now());
  ctx.verbose && console.log(event.name);

  let markets = await fetchMarkets(event.id);
  markets = markets.map((market: any) => ({
    ...market,
    // smarkets doesn't have separate urls for different markets in a single event
    // we could use anchors (e.g. https://smarkets.com/event/886716/politics/uk/uk-party-leaders/next-conservative-leader#contract-collapse-9815728-control), but it's unclear if they aren't going to change
    slug: event.full_slug,
  }));
  ctx.verbose && console.log(`Markets for ${event.id} fetched`);
  ctx.verbose && console.log(markets);

  let results: FetchedQuestion[] = [];
  for (const market of markets) {
    ctx.verbose && console.log("================");
    ctx.verbose && console.log("Market:", market);

    const contracts = await fetchContracts(market.id, ctx);
    ctx.verbose && console.log("Contracts:", contracts);
    const prices = await fetchPrices(market.id, ctx);
    ctx.verbose && console.log("Prices:", prices[market.id]);

    let optionsObj: {
      [k: string]: QuestionOption;
    } = {};

    const contractsById = Object.fromEntries(
      contracts.map((c) => [c.id as string, c])
    );

    for (const price of prices[market.id]) {
      const contract = contractsById[price.contract_id];
      if (!contract) {
        console.warn(
          `Couldn't find contract ${price.contract_id} in contracts data for ${market.id}, event ${market.event_id}, skipping`
        );
        continue;
      }
      optionsObj[price.contract_id] = {
        name: contract.name,
        probability: contract.hidden ? 0 : Number(price.last_executed_price),
        type: "PROBABILITY",
      };
    }
    let options: QuestionOption[] = Object.values(optionsObj);
    ctx.verbose && console.log("Options before patching:", options);

    // monkey patch the case where there are only two options and only one has traded.
    if (
      options.length === 2 &&
      options.map((option) => option.probability).includes(0)
    ) {
      const nonNullPrice = options[0].probability || options[1].probability;

      if (nonNullPrice) {
        options = options.map((option) => {
          return {
            ...option,
            probability: option.probability || 100 - nonNullPrice,
            // yes, 100, because prices are not yet normalized.
          };
        });
      }
    }
    ctx.verbose && console.log("Options after patching:", options);

    // Normalize normally
    const totalValue = options
      .map((element) => Number(element.probability))
      .reduce((a, b) => a + b, 0);

    options = options.map((element) => ({
      ...element,
      probability: Number(element.probability) / totalValue,
    }));
    ctx.verbose && console.log("Normalized options:", options);

    const result: FetchedQuestion = {
      id: `${platformName}-${market.id}`,
      title: market.name,
      url: "https://smarkets.com/event/" + market.event_id + market.slug,
      description: market.description,
      options,
      qualityindicators: {},
      extra: {
        contracts,
        prices,
      },
    };
    ctx.verbose && console.log(result);
    results.push(result);
  }
  return results;
}

export const smarkets: Platform = {
  name: platformName,
  label: "Smarkets",
  color: "#6f5b41",

  extendCliCommand(command) {
    command
      .command("fetch-one")
      .argument("<id>", "Fetch a single question by id")
      .action(async (eventId) => {
        const events = [
          await fetchSingleEvent(eventId, {
            verbose: !!process.env["DEBUG"]!,
          }),
        ];
        await saveQuestions({
          platform: smarkets,
          fetchedQuestions: events,
        });
      });
  },

  async fetcher() {
    const ctx = {
      verbose: !!process.env["DEBUG"]!,
    };

    const events = await fetchEvents(ctx);

    let questions: FetchedQuestion[] = [];
    for (const event of events) {
      const eventResults = await processEventMarkets(event, ctx);
      questions.push(...eventResults);
    }

    return { questions };
  },

  calculateStars() {
    return 2; // Nuño
  },
};



---
File: /src/backend/platforms/wildeford.ts
---

/* Imports */
import { GoogleSpreadsheet } from "google-spreadsheet";

import { FetchedQuestion, Platform } from "../types";
import { applyIfSecretExists } from "../utils/getSecrets";
import { hash } from "../utils/hash";

/* Definitions */
const platformName = "wildeford";
const SHEET_ID = "1xcgYF7Q0D95TPHLLSgwhWBHFrWZUGJn7yTyAhDR4vi0"; // spreadsheet key is the long id in the sheets URL
const endpoint = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/edit#gid=0`;
// https://docs.google.com/spreadsheets/d/1xcgYF7Q0D95TPHLLSgwhWBHFrWZUGJn7yTyAhDR4vi0/edit#gid=0
/* Support functions */

const formatRow = (row: string[]) => {
  const colNames = [
    "Prediction Date",
    "Prediction",
    "Odds",
    "Actual",
    "Resolution Date",
    "Prediction Right?",
    "Brier Score",
    "Notes",
  ] as const;

  const result: Partial<{ [k in (typeof colNames)[number]]: string }> = {};
  row.forEach((col: string, i) => {
    result[colNames[i]] = col;
  });
  return result as Required<typeof result>;
};

async function fetchGoogleDoc(google_api_key: string) {
  // https://gist.github.com/micalevisk/9bc831bd4b3e5a3f62b9810330129c59
  let results = [];
  const doc = new GoogleSpreadsheet(SHEET_ID);
  doc.useApiKey(google_api_key);

  await doc.loadInfo(); // loads document properties and worksheets
  console.log(">>", doc.title);

  const sheet = doc.sheetsByIndex[0];
  const rows = await sheet.getRows();

  console.log("# " + rows[0]["_sheet"].headerValues.join(","));
  let isEnd = false;
  for (let i in rows) {
    let data = rows[i]["_rawData"];
    if (data.length == 0) isEnd = true;
    if (!isEnd) {
      let result = {
        ...formatRow(data),
        url: endpoint + `&range=A${Number(i) + 2}`,
      };
      // +2: +1 for the header row, +1 for starting at 1 and not at 0.
      // console.log(result)
      results.push(result);

      // console.log(rows[i])
      // console.log(rows[i]._rawData)
      // console.log(rows[i]["Prediction"])
    }
    // console.log(row._rawData.join(','))
    // console.log(row._rawData.join(','))
  }
  // console.log(results)
  return results;
}

async function processPredictions(
  predictions: Awaited<ReturnType<typeof fetchGoogleDoc>>
) {
  let currentPredictions = predictions.filter(
    (prediction) => prediction["Actual"] == "Unknown"
  );
  let results = currentPredictions.map((prediction) => {
    let title = prediction["Prediction"].replace(" [update]", "");
    let id = `${platformName}-${hash(title)}`;
    let probability = Number(prediction["Odds"].replace("%", "")) / 100;
    let options: FetchedQuestion["options"] = [
      {
        name: "Yes",
        probability: probability,
        type: "PROBABILITY",
      },
      {
        name: "No",
        probability: 1 - probability,
        type: "PROBABILITY",
      },
    ];
    let result: FetchedQuestion = {
      id,
      title,
      url: prediction["url"],
      description: prediction["Notes"] || "",
      options,
      //// TODO - use `created` field for this
      // timestamp: new Date(Date.parse(prediction["Prediction Date"] + "Z")),
      qualityindicators: {},
    };
    return result;
  });

  results = results.reverse();
  let uniqueTitles: string[] = [];
  let uniqueResults: FetchedQuestion[] = [];
  results.forEach((result) => {
    if (!uniqueTitles.includes(result.title)) uniqueResults.push(result);
    uniqueTitles.push(result.title);
  });
  return uniqueResults;
}

export async function wildeford_inner(google_api_key: string) {
  let predictions = await fetchGoogleDoc(google_api_key);
  return await processPredictions(predictions);
}

export const wildeford: Platform = {
  name: platformName,
  label: "Peter Wildeford",
  color: "#984158",

  async fetcher() {
    const GOOGLE_API_KEY = process.env["GOOGLE_API_KEY"]!; // See: https://developers.google.com/sheets/api/guides/authorizing#APIKey
    const questions = await applyIfSecretExists(
      GOOGLE_API_KEY,
      wildeford_inner
    );
    if (!questions) {
      return null;
    }
    return { questions };
  },

  calculateStars() {
    return 3; // Nuño
  },
};



---
File: /src/backend/platforms/xrisk.ts
---

import fs from "fs";

import { Platform } from "../types";
import { hash } from "../utils/hash";

const platformName = "xrisk";

/*
 * Original source of data: https://docs.google.com/spreadsheets/d/1W10B6NJjicD8O0STPiT3tNV3oFnT8YsfjmtYR8RO_RI/edit?gid=0#gid=0
 */

export const xrisk: Platform = {
  name: "xrisk",
  label: "X-risk estimates",
  color: "#272600",

  async fetcher() {
    // return; // not necessary to refill the DB every time
    const fileRaw = fs.readFileSync("./input/xrisk-questions.json", {
      encoding: "utf-8",
    });
    const parsedData = JSON.parse(fileRaw);
    const results = parsedData.map((item: any) => {
      item.extra = item.moreoriginsdata;
      delete item.moreoriginsdata;
      return {
        ...item,
        id: `${platformName}-${hash(item.title + " | " + item.url)}`, // some titles are non-unique, but title+url pair is always unique
      };
    });
    return { questions: results };
  },

  calculateStars() {
    return 2;
  },
};



---
File: /src/backend/utils/misc/process-forecasts-into-elicit.ts
---

/* Imports */
import fs from "fs";

import { prisma } from "@quri/metaforecast-db";

import { QualityIndicators } from "@/backend/types";

/* Definitions */
let locationData = "./data/";

/* Body */
// let rawdata =  fs.readFileSync("./data/merged-questions.json") // run from topmost folder, not from src
async function main() {
  const data = await prisma.question.findMany({});
  const processDescription = (description: string | null | undefined) => {
    if (description == null || description == undefined || description == "") {
      return "";
    } else {
      description =
        description == null
          ? ""
          : description
              .replaceAll("] (", "](")
              .replaceAll(") )", "))")
              .replaceAll("( [", "([")
              .replaceAll(") ,", "),")
              .replaceAll("\n", " ");
      if (description.length > 1000) {
        return description.slice(0, 1000) + "...";
      } else {
        return description;
      }
    }
  };

  let results = [];
  for (const datum of data) {
    // do something
    const description = processDescription(datum["description"]);
    const forecasts = datum["qualityindicators"]
      ? (datum["qualityindicators"] as object as QualityIndicators).numforecasts
      : "unknown";
    const stars = datum["qualityindicators"]
      ? (datum["qualityindicators"] as object as QualityIndicators).stars
      : 2;
    results.push("Title: " + datum["title"]);
    results.push("URL: " + datum["url"]);
    results.push("Platform: " + datum["platform"]);
    results.push("Description: " + description);
    results.push("Number of forecasts: " + forecasts);
    results.push("Stars: " + forecasts);
    results.push("\n");
  }

  let string = results.join("\n");
  string = string.replaceAll("\n\n", "\n");

  fs.writeFileSync("elicit-output.txt", string);
}
main();



---
File: /src/backend/utils/misc/process-forecasts-template.ts
---

/* Imports */
import fs from "fs";

/* Definitions */
let locationData = "./data/";

/* Body */
let rawdata = fs.readFileSync("../data/merged-questions.json", {
  encoding: "utf-8",
});
let data = JSON.parse(rawdata);

let results: any[] = [];
for (let datum of data) {
  // do something
}

let string = JSON.stringify(results, null, 2);
fs.writeFileSync("../data/output.txt", string);



---
File: /src/backend/utils/misc/test.ts
---

import axios from "axios";

let elicitEndpoint =
  "https://elicit.org/api/v1/binary-questions/csv?binaryQuestions.resolved=false&binaryQuestions.search=&binaryQuestions.sortBy=popularity&predictors=community";

let main = async () => {
  let response = await axios.get(elicitEndpoint).then((query) => query.data);

  console.log(response);
};
main();



---
File: /src/backend/utils/elastic.ts
---

import { Client as ElasticClient } from "@elastic/elasticsearch";
import crypto from "crypto";

import { prisma, Question } from "@quri/metaforecast-db";

import { platformNameToLabel } from "../platformRegistry";

let _CACHED_CLIENT: ElasticClient | null = null;
function getClient() {
  if (!_CACHED_CLIENT) {
    _CACHED_CLIENT = new ElasticClient({
      node: process.env["ELASTIC_HOST"]!,
      auth: {
        username: process.env["ELASTIC_USER"]!,
        password: process.env["ELASTIC_PASSWORD"]!,
      },
    });
  }
  return _CACHED_CLIENT;
}

const ALIAS_NAME = process.env["ELASTIC_INDEX"]!;

export type ElasticQuestion = Omit<Question, "fetched" | "firstSeen"> & {
  fetched: string;
  firstSeen: string;
  optionsstringforsearch?: string;
  platformLabel: string;
  objectID: string;
};

function getoptionsstringforsearch(record: Question): string {
  let result = "";
  if (!!record.options && (record.options as any[]).length > 0) {
    result = (record.options as any[])
      .map((option: any) => option.name || null)
      .filter((x: any) => x != null)
      .join(", ");
  }
  return result;
}

export function questionToElasticDocument(question: Question): ElasticQuestion {
  return {
    ...question,
    fetched: question.fetched.toISOString(),
    firstSeen: question.firstSeen.toISOString(),
    platformLabel: platformNameToLabel(question.platform),
    objectID: question.id,
    optionsstringforsearch: getoptionsstringforsearch(question),
  };
}

export async function indexQuestions(questions: Question[]) {
  const client = getClient();

  // add questions to the existing index
  let count = 0;
  let operations: { id: string; document: ElasticQuestion }[] = [];

  const flush = async () => {
    if (!operations.length) return;
    await client.bulk({
      operations: operations.flatMap((op) => [
        { index: { _index: ALIAS_NAME, _id: op.id } },
        op.document,
      ]),
    });
    count += operations.length;
    console.log(count);
    operations = [];
  };

  for (const question of questions) {
    operations.push({
      id: question.id,
      document: questionToElasticDocument(question),
    });
    if (operations.length >= 100) {
      await flush();
    }
  }
  await flush();
  console.log(`Pushed ${count} records to Elasticsearch.`);
}

export async function deleteQuestionsFromIndex(questionIds: string[]) {
  const client = getClient();
  await client.deleteByQuery({
    index: ALIAS_NAME,
    body: { query: { ids: { values: questionIds } } },
  });
}

export async function rebuildElasticDatabase() {
  const questions = await prisma.question.findMany();

  const oldIndexNames: string[] = [];
  if (await getClient().indices.existsAlias({ name: ALIAS_NAME })) {
    const alias = await getClient().indices.getAlias({ name: ALIAS_NAME });
    oldIndexNames.push(...Object.keys(alias));
  }

  const suffix = crypto.randomBytes(16).toString("hex");
  const index = `${ALIAS_NAME}-${suffix}`;

  console.log(`Creating a new index ${index}`);
  await getClient().indices.create({
    index,
    settings: {
      number_of_replicas: 0,
    },
  });

  await indexQuestions(questions);

  console.log("Switching alias to new index");
  await getClient().indices.updateAliases({
    body: {
      actions: [
        { remove: { index: "*", alias: ALIAS_NAME } },
        { add: { index, alias: ALIAS_NAME } },
      ],
    },
  });

  for (const oldIndexName of oldIndexNames) {
    console.log(`Removing old index ${oldIndexName}`);
    await getClient().indices.delete({ index: oldIndexName });
  }
}



---
File: /src/backend/utils/fetchUtils.ts
---

import { sleep } from "./sleep";

export async function fetchJson(
  endpoint: string,
  {
    retries = 3,
  }: {
    retries?: number;
  } = {}
): Promise<unknown> {
  let lastError: Error | null = null;

  for (let attempt = 0; attempt < retries; attempt++) {
    try {
      const response = await fetch(endpoint);
      if (!response.ok) {
        throw new Error(
          `HTTP error ${response.status}: ${response.statusText}`
        );
      }
      return response.json();
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error));
      console.warn(
        `Fetch attempt ${attempt + 1}/${retries} failed:`,
        lastError.message
      );

      if (attempt < retries - 1) {
        // Exponential backoff with jitter
        const delay =
          Math.min(1000 * Math.pow(2, attempt), 10000) *
          (0.75 + Math.random() * 0.5);
        await sleep(delay);
      }
    }
  }

  throw lastError || new Error("Failed to fetch after multiple attempts");
}



---
File: /src/backend/utils/getSecrets.ts
---

export async function applyIfSecretExists<T>(
  cookie: string | undefined,
  fun: (cookie: string) => T
) {
  if (cookie) {
    return await fun(cookie);
  } else {
    console.log(
      `Cannot proceed with ${fun.name} because cookie does not exist`
    );
    throw new Error(`No cookie for ${fun.name}`);
  }
}



---
File: /src/backend/utils/hash.ts
---

import crypto from "crypto";

export function hash(string: string) {
  return crypto.createHash("sha256").update(string).digest("hex").slice(0, 10);
}



---
File: /src/backend/utils/measureTime.ts
---

export async function measureTime(f: () => Promise<void>) {
  const init = Date.now();
  await f();
  const end = Date.now();
  const difference = end - init;
  console.log(
    `Took ${difference / 1000} seconds, or ${difference / (1000 * 60)} minutes.`
  );
}



---
File: /src/backend/utils/sleep.ts
---

export function sleep(ms: number) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}



---
File: /src/backend/utils/toMarkdown.ts
---

import textVersion from "textversionjs";

export default function toMarkdown(htmlText: string) {
  let html2 = htmlText.replaceAll(`='`, `="`).replaceAll(`'>`, `">`);
  return textVersion(html2, {
    linkProcess: (href, linkText) => {
      let newHref = href
        ? href.replace(/\(/g, "%28").replace(/\)/g, "%29")
        : "";
      // Deal correctly in markdown with links that contain parenthesis
      return `[${linkText}](${newHref})`;
    },
  });
}

// toMarkdown()
// console.log(toMarkdown("Context:Many intellectual endeavors require mathematical problem solving, but this skill remains beyond the capabilities of computers. To help advance the art, the <a target=_new href='https://github.com/hendrycks/math/'>MATH</a> dataset offers..."))



---
File: /src/backend/dbUtils.ts
---

import { prisma, Question } from "@quri/metaforecast-db";

import { FetchedQuestion, Platform } from "./types";
import { deleteQuestionsFromIndex, indexQuestions } from "./utils/elastic";

// Typing notes:
// There's a difference between prisma's Question type (type returned from `find` and `findMany`) and its input types due to JsonValue vs InputJsonValue mismatch.
// On the other hand, we can't use Prisma.QuestionUpdateInput or Prisma.QuestionCreateManyInput either, because we use this question in guesstimate's code for preparing questions from guesstimate models...
// So here we build a new type which should be ok to use both in place of prisma's Question type and as an input to its update or create methods.
type PreparedQuestion = Omit<
  Question,
  "extra" | "qualityindicators" | "options" | "fetched" | "firstSeen"
> & {
  fetched: Date;
  extra: NonNullable<Question["extra"]>;
  qualityindicators: NonNullable<Question["qualityindicators"]>;
  options: NonNullable<Question["options"]>;
};

export function prepareQuestion(
  q: FetchedQuestion,
  platform: Platform
): PreparedQuestion {
  return {
    extra: {},
    ...q,
    fetched: new Date(),
    platform: platform.name,
    qualityindicators: {
      ...q.qualityindicators,
      stars: platform.calculateStars(q),
    },
  };
}

async function updateHistory(questions: PreparedQuestion[]) {
  if (questions.length === 0) return;

  // Get all question IDs
  const questionIds = questions.map((q) => q.id);

  // Find the latest history entries for these questions
  const latestHistoryEntries = await prisma.history.findMany({
    where: {
      id: { in: questionIds },
    },
    orderBy: {
      fetched: "desc",
    },
    distinct: ["id"],
    select: {
      id: true,
      pk: true,
      fetched: true,
    },
  });

  // Create a map of question ID to latest history entry for quick lookup
  const historyMap = new Map(
    latestHistoryEntries.map((entry) => [entry.id, entry])
  );

  // Define a function to calculate the "bucket" for a timestamp
  // Each bucket represents a 24-hour period since Unix epoch
  const getBucket = (date: Date): number => {
    return Math.floor(date.getTime() / (24 * 60 * 60 * 1000));
  };

  // Split questions into those needing new history entries and those that need updates
  const questionsToCreate: PreparedQuestion[] = [];
  const questionsToUpdate: Array<{
    question: PreparedQuestion;
    historyPk: number;
  }> = [];

  for (const q of questions) {
    const latestEntry = historyMap.get(q.id);

    if (!latestEntry || getBucket(latestEntry.fetched) < getBucket(q.fetched)) {
      // Create new history entry if:
      // 1. No previous history exists, or
      // 2. The latest history entry is older than our threshold
      questionsToCreate.push(q);
    } else {
      // Update existing history entry if it's recent
      questionsToUpdate.push({ question: q, historyPk: latestEntry.pk });
    }
  }

  // Create new history entries in bulk
  if (questionsToCreate.length > 0) {
    await prisma.history.createMany({
      data: questionsToCreate.map((q) => ({
        ...q,
        idref: q.id,
      })),
    });
  }

  // Update existing history entries one by one
  for (const { question, historyPk } of questionsToUpdate) {
    await prisma.history.update({
      where: { pk: historyPk },
      data: {
        ...question,
        idref: question.id,
      },
    });
  }

  // Log the number of created and updated history entries
  console.log(
    `History updated: ${questionsToCreate.length} created, ${questionsToUpdate.length} updated`
  );
}

// Used only by Guesstimate platform
export async function upsertSingleQuestion(
  q: PreparedQuestion
): Promise<Question> {
  return await prisma.question.upsert({
    where: { id: q.id },
    create: {
      ...q,
      firstSeen: new Date(),
    },
    update: q,
  });
  // TODO - update history?
}

type SaveStats = {
  created?: number;
  updated?: number;
  deleted?: number;
};

type SaveParams = {
  platform: Platform;
  fetchedQuestions: FetchedQuestion[];
  replaceAll?: boolean; // if set, delete all existing questions for this platform
  index?: boolean;
};

export async function saveQuestions({
  platform,
  fetchedQuestions,
  replaceAll,
  index,
}: SaveParams): Promise<SaveStats> {
  // Bulk update, optimized for performance.

  const oldQuestions = await prisma.question.findMany({
    where: { platform: platform.name },
    select: { id: true },
  });

  const fetchedIds = fetchedQuestions.map((q) => q.id);
  const oldIds = oldQuestions.map((q) => q.id);

  const fetchedIdsSet = new Set(fetchedIds);
  const oldIdsSet = new Set(oldIds);

  const questionsToCreate: PreparedQuestion[] = [];
  const questionsToUpdate: PreparedQuestion[] = [];
  const idsToDelete = oldIds.filter((id) => !fetchedIdsSet.has(id));

  const preparedQuestions = fetchedQuestions.map((q) =>
    prepareQuestion(q, platform)
  );

  // Sort questions into "created" and "updated" lists.
  for (const q of preparedQuestions) {
    if (oldIdsSet.has(q.id)) {
      // TODO - check if question has changed for better performance; bulk selects are faster than one-by-one updates.
      questionsToUpdate.push(q);
    } else {
      questionsToCreate.push(q);
    }
  }

  const stats: SaveStats = {};

  await prisma.question.createMany({
    data: questionsToCreate.map((q) => ({
      ...q,
      firstSeen: new Date(),
    })),
  });
  stats.created = questionsToCreate.length;

  const updatedQuestions: Question[] = [];
  for (const q of questionsToUpdate) {
    const updatedQuestion = await prisma.question.update({
      where: { id: q.id },
      data: q,
    });
    updatedQuestions.push(updatedQuestion);
    stats.updated ??= 0;
    stats.updated++;
  }

  if (replaceAll) {
    // TODO - transaction?
    await prisma.question.deleteMany({
      where: {
        id: { in: idsToDelete },
      },
    });
    stats.deleted = idsToDelete.length;
  }

  await updateHistory([...questionsToCreate, ...questionsToUpdate]);

  if (index) {
    const questionsToIndex = await prisma.question.findMany({
      where: {
        id: {
          in: [...questionsToCreate, ...questionsToUpdate].map((q) => q.id),
        },
      },
    });
    await indexQuestions(questionsToIndex);
  }

  return stats;
}

export async function saveQuestionsWithStats(params: SaveParams) {
  const stats = await saveQuestions(params);

  console.log(
    "Done, " +
      Object.entries(stats)
        .map(([k, v]) => `${v} ${k}`)
        .join(", ")
  );
}

export async function saveResolvedQuestions(questionIds: string[]) {
  // Metaforecast doesn't support resolved questions yet, so we delete them.

  console.log(`Deleting ${questionIds.length} resolved questions from DB`);
  // Process in batches of 1000 to avoid potential issues with large arrays
  for (let i = 0; i < questionIds.length; i += 1000) {
    const batch = questionIds.slice(i, i + 1000);
    await prisma.question.deleteMany({
      where: {
        id: { in: batch },
      },
    });
    console.log(
      `Deleted batch ${i / 1000 + 1}: ${batch.length} questions from database`
    );
  }

  console.log(`Deleting ${questionIds.length} resolved questions from index`);

  // Process in batches of 1000 to avoid potential issues with large arrays
  for (let i = 0; i < questionIds.length; i += 1000) {
    const batch = questionIds.slice(i, i + 1000);
    await deleteQuestionsFromIndex(batch);
    console.log(
      `Deleted batch ${i / 1000 + 1}: ${batch.length} questions from index`
    );
  }

  console.log(`Deleted ${questionIds.length} resolved questions`);
}



---
File: /src/backend/frontpage.ts
---

import { prisma, Question } from "@quri/metaforecast-db";

import { measureTime } from "./utils/measureTime";

export async function getFrontpage(): Promise<Question[]> {
  const questions = (
    await prisma.frontpageId.findMany({
      include: {
        question: true,
      },
    })
  )
    .map((f) => f.question)
    .filter((q) => q);
  return questions;
}

export async function rebuildFrontpage() {
  await measureTime(async () => {
    const rows = await prisma.$queryRaw<{ id: string }[]>`
      SELECT questions.id FROM questions, history
      WHERE
        questions.id = history.id
        AND (questions.qualityindicators->>'stars')::int >= 2
        AND questions.description != ''
				AND questions.url NOT LIKE '%kalshi%'
        AND JSONB_ARRAY_LENGTH(questions.options) > 0
      GROUP BY questions.id
      ORDER BY RANDOM() LIMIT 50
    `;

    await prisma.$transaction([
      prisma.frontpageId.deleteMany({}),
      prisma.frontpageId.createMany({
        data: rows,
      }),
    ]);
  });
}



---
File: /src/backend/platformRegistry.ts
---

import { betfair } from "./platforms/betfair";
import { fantasyscotus } from "./platforms/fantasyscotus";
import { foretold } from "./platforms/foretold";
import { givewellopenphil } from "./platforms/givewellopenphil";
import { goodjudgment } from "./platforms/goodjudgment";
import { goodjudgmentopen } from "./platforms/goodjudgmentopen";
import { guesstimate } from "./platforms/guesstimate";
import { infer } from "./platforms/infer";
import { insight } from "./platforms/insight";
import { kalshi } from "./platforms/kalshi";
import { manifold } from "./platforms/manifold";
import { metaculus } from "./platforms/metaculus";
import { polymarket } from "./platforms/polymarket";
import { predictit } from "./platforms/predictit";
import { rootclaim } from "./platforms/rootclaim";
import { smarkets } from "./platforms/smarkets";
import { wildeford } from "./platforms/wildeford";
import { xrisk } from "./platforms/xrisk";
import { Platform, PlatformConfig } from "./types";

// function instead of const array, this helps with circular dependencies
export function getPlatforms(
  opts: {
    withDailyFetcherOnly?: boolean;
  } = {}
): Platform[] {
  const platforms: Platform[] = [
    betfair,
    fantasyscotus,
    foretold,
    givewellopenphil,
    goodjudgment,
    goodjudgmentopen,
    guesstimate,
    infer,
    insight,
    kalshi,
    manifold,
    metaculus,
    polymarket,
    predictit,
    rootclaim,
    smarkets,
    wildeford,
    xrisk,
  ];

  if (opts.withDailyFetcherOnly) {
    return platforms.filter((platform) => platform.fetcher);
  }

  return platforms;
}

let _nameToLabelCache: { [k: string]: string } | undefined;
export function platformNameToLabel(name: string): string {
  if (!_nameToLabelCache) {
    _nameToLabelCache = Object.fromEntries(
      getPlatforms().map((platform) => [platform.name, platform.label])
    );
  }
  return _nameToLabelCache[name] || name;
}

// get frontend-safe version of platforms data
export function getPlatformsConfig(): PlatformConfig[] {
  const platformsConfig = getPlatforms().map((platform) => ({
    name: platform.name,
    label: platform.label,
    color: platform.color,
  }));

  return platformsConfig;
}



---
File: /src/backend/platformUtils.ts
---

import { z } from "zod";

import { prisma } from "@quri/metaforecast-db";

import { saveQuestionsWithStats } from "./dbUtils";
import { Platform } from "./types";

export async function getPlatformState<TState extends z.ZodTypeAny>(
  platform: Platform<TState>
): Promise<z.infer<TState> | null> {
  if (!platform.stateSchema) {
    throw new Error("Platform has no state schema");
  }
  const state = await prisma.platformState.findUnique({
    where: {
      platform: platform.name,
    },
  });
  if (!state) {
    return null;
  }

  // TODO - recover from errors?
  const parsed = platform.stateSchema.parse(state.state);
  return parsed;
}

export async function setPlatformState<TState extends z.ZodTypeAny>(
  platform: Platform<TState>,
  state: z.infer<TState>
) {
  await prisma.platformState.upsert({
    where: {
      platform: platform.name,
    },
    update: {
      state,
    },
    create: {
      platform: platform.name,
      state,
    },
  });
}

// Run the platform's daily fetcher and save the results.
export async function processPlatform(platform: Platform) {
  if (!platform.fetcher) {
    console.log(`Platform ${platform.name} doesn't have a fetcher, skipping`);
    return;
  }
  const result = await platform.fetcher();

  if (!result || !result.questions) {
    console.log(`Platform ${platform.name} didn't return any results`);
    return;
  }

  const { questions } = result;

  await saveQuestionsWithStats({
    platform,
    fetchedQuestions: questions,
    replaceAll: true,
  });
}



---
File: /src/backend/types.ts
---

import { type Command } from "@commander-js/extra-typings";
import { z } from "zod";

import { Question } from "@quri/metaforecast-db";

import { QuestionOption } from "@/common/types";

export type QualityIndicators = {
  stars: number;
  numforecasts?: number | string;
  numforecasters?: number;
  liquidity?: number | string;
  volume?: number;
  volume7Days?: number;
  volume24Hours?: number;
  address?: number;
  tradevolume?: string;
  pool?: Record<string, number>;
  createdTime?: any;
  shares_volume?: any;
  yes_bid?: any;
  yes_ask?: any;
  spread?: any;
  open_interest?: any;
  trade_volume?: any;
};

export type FetchedQuestion = Omit<
  Question,
  | "extra"
  | "qualityindicators"
  | "fetched"
  | "firstSeen"
  | "platform"
  | "options"
> & {
  extra?: object; // required in DB but annoying to return empty; also this is slightly stricter than Prisma's JsonValue
  options: QuestionOption[]; // stronger type than Prisma's JsonValue
  qualityindicators: Omit<QualityIndicators, "stars">; // slightly stronger type than Prisma's JsonValue
};

// fetcher should return null if platform failed to fetch questions for some reason
type PlatformFetcherResult = {
  questions: FetchedQuestion[];
} | null;
type PlatformFetcher = () => Promise<PlatformFetcherResult>;

// using "" as ArgNames default is technically incorrect, but shouldn't cause any real issues
// (I couldn't find a better solution for signifying an empty value, though there probably is one)
export type Platform<TState extends z.ZodTypeAny = any> = {
  name: string; // short name for ids and `platform` db column, e.g. "xrisk"
  label: string; // longer name for displaying on frontend etc., e.g. "X-risk estimates"
  color: string; // used on frontend
  calculateStars: (question: FetchedQuestion) => number;
  // extended commander configuration, e.g. subcommands
  extendCliCommand?: (command: Command) => void;

  // fetchers are optional
  fetcher?: PlatformFetcher;

  stateSchema?: TState;
};

export type PlatformConfig = {
  name: string;
  label: string;
  color: string;
};



---
File: /src/common/types.ts
---

import { QuestionFragment } from "../web/fragments.generated";

// this type is good both for backend (e.g. FetchedQuestion["options"]) and for graphql shapes
export type QuestionOption = {
  name?: string;
  probability?: number;
  type: "PROBABILITY";
};

export type FullQuestionOption = Exclude<
  QuestionOption,
  "name" | "probability"
> & {
  name: NonNullable<QuestionOption["name"]>;
  probability: NonNullable<QuestionOption["probability"]>;
};

export function isFullQuestionOption(
  option: QuestionOption | QuestionFragment["options"][0]
): option is FullQuestionOption {
  return option.name != null && option.probability != null;
}



---
File: /src/graphql/schema/dashboards.ts
---

import { Dashboard, prisma } from "@quri/metaforecast-db";

import { hash } from "../../backend/utils/hash";
import { builder } from "../builder";
import { QuestionObj } from "./questions";

const DashboardObj = builder.objectRef<Dashboard>("Dashboard").implement({
  fields: (t) => ({
    id: t.exposeID("id"),
    title: t.exposeString("title", {
      description: "The title of the dashboard",
    }),
    description: t.exposeString("description", {
      description: "The longer description of the dashboard",
    }),
    creator: t.exposeString("creator", {
      description: 'The creator of the dashboard, e.g. "Peter Parker"',
    }),
    questions: t.field({
      type: [QuestionObj],
      description: "The list of questions on the dashboard",
      resolve: async (parent) => {
        return await prisma.question.findMany({
          where: {
            id: {
              in: parent.contents as string[],
            },
          },
        });
      },
    }),
  }),
});

builder.queryField("dashboard", (t) =>
  t.field({
    type: DashboardObj,
    nullable: true,
    description: "Look up a single dashboard by its id",
    args: {
      id: t.arg({ type: "ID", required: true }),
    },
    resolve: async (parent, args) => {
      return await prisma.dashboard.findUnique({
        where: {
          id: String(args.id),
        },
      });
    },
  })
);

const CreateDashboardResult = builder
  .objectRef<{ dashboard: Dashboard }>("CreateDashboardResult")
  .implement({
    fields: (t) => ({
      dashboard: t.field({
        type: DashboardObj,
        resolve: (parent) => parent.dashboard,
      }),
    }),
  });

const CreateDashboardInput = builder.inputType("CreateDashboardInput", {
  fields: (t) => ({
    title: t.string({
      required: true,
      description: "The title of the dashboard",
    }),
    description: t.string({
      description: "The longer description of the dashboard",
    }),
    creator: t.string({
      description: 'The creator of the dashboard, e.g. "Peter Parker"',
    }),
    ids: t.idList({ required: true, description: "List of question ids" }),
  }),
});

builder.mutationField("createDashboard", (t) =>
  t.field({
    type: CreateDashboardResult,
    description:
      "Create a new dashboard; if the dashboard with given ids already exists then it will be returned instead.",
    args: {
      input: t.arg({ type: CreateDashboardInput, required: true }),
    },
    resolve: async (parent, args) => {
      const id = hash(JSON.stringify(args.input.ids));
      const dashboard = await prisma.dashboard.upsert({
        where: {
          id,
        },
        update: {},
        create: {
          id,
          title: args.input.title,
          description: args.input.description || "",
          creator: args.input.creator || "",
          contents: args.input.ids,
          extra: [],
          timestamp: new Date(),
        },
      });
      return {
        dashboard,
      };
    },
  })
);



---
File: /src/graphql/schema/frontpage.ts
---

import { getFrontpage } from "../../backend/frontpage";
import { builder } from "../builder";
import { QuestionObj } from "./questions";

builder.queryField("frontpage", (t) =>
  t.field({
    type: [QuestionObj],
    description: "Get a list of questions that are currently on the frontpage",
    resolve: async () => {
      return await getFrontpage();
    },
  })
);



---
File: /src/graphql/schema/index.ts
---

import "./dashboards";
import "./frontpage";
import "./questions";
import "./search";

import { builder } from "../builder";

export const schema = builder.toSchema({});



---
File: /src/graphql/schema/platforms.ts
---

import { prisma } from "@quri/metaforecast-db";

import { manifold } from "@/backend/platforms/manifold";
import { getPlatformState } from "@/backend/platformUtils";

import { getPlatforms } from "../../backend/platformRegistry";
import { builder } from "../builder";

export const PlatformObj = builder.objectRef<string>("Platform").implement({
  description: "Forecasting platform supported by Metaforecast",
  fields: (t) => ({
    id: t.id({
      description: 'Short unique platform name, e.g. "xrisk"',
      resolve: (x) => x,
    }),
    label: t.string({
      description:
        'Platform name for displaying on frontend etc., e.g. "X-risk estimates"',
      resolve: (platformName) => {
        if (platformName === "metaforecast") {
          return "Metaforecast";
        }
        const platform = getPlatforms().find((p) => p.name === platformName);
        if (!platform) {
          throw new Error(`Unknown platform ${platformName}`);
        }
        return platform.label;
      },
    }),
    lastUpdated: t.field({
      type: "Date",
      nullable: true,
      resolve: async (platformName) => {
        if (platformName === "manifold") {
          const state = await getPlatformState(manifold);
          if (state?.lastFetched) {
            return new Date(state.lastFetched);
          }
          return null;
        }

        const res = await prisma.question.aggregate({
          where: {
            platform: platformName,
          },
          _max: {
            fetched: true,
          },
        });
        return res._max.fetched;
      },
    }),
  }),
});

builder.queryField("platforms", (t) =>
  t.field({
    type: [PlatformObj],
    resolve: async (parent, args) => {
      return getPlatforms().map((platform) => platform.name);
    },
  })
);



---
File: /src/graphql/schema/questions.ts
---

import { History, prisma, Question } from "@quri/metaforecast-db";

import { QualityIndicators } from "@/backend/types";

import { guesstimate } from "../../backend/platforms/guesstimate";
import { builder } from "../builder";
import { PlatformObj } from "./platforms";

export const QualityIndicatorsObj = builder
  .objectRef<QualityIndicators>("QualityIndicators")
  .implement({
    description: "Various indicators of the question's quality",
    fields: (t) => {
      const maybeIntField = (name: keyof QualityIndicators) =>
        t.int({
          nullable: true,
          resolve: (parent) =>
            parent[name] === undefined ? undefined : Number(parent[name]),
        });
      const maybeFloatField = (name: keyof QualityIndicators) =>
        t.float({
          nullable: true,
          resolve: (parent) =>
            parent[name] === undefined ? undefined : Number(parent[name]),
        });

      return {
        stars: t.exposeInt("stars", {
          description: "0 to 5",
        }),
        numForecasts: maybeIntField("numforecasts"),
        numForecasters: maybeIntField("numforecasters"),
        volume: maybeFloatField("volume"),
        // yesBid: maybeNumberField("yes_bid"),
        // yesAsk: maybeNumberField("yes_ask"),
        spread: maybeFloatField("spread"),
        sharesVolume: maybeFloatField("shares_volume"),
        openInterest: maybeFloatField("open_interest"),
        liquidity: maybeFloatField("liquidity"),
        tradeVolume: maybeFloatField("trade_volume"),
      };
    },
  });

export const ProbabilityOptionObj = builder
  .objectRef<{ name: string; probability: number }>("ProbabilityOption")
  .implement({
    fields: (t) => ({
      name: t.exposeString("name", { nullable: true }),
      probability: t.exposeFloat("probability", {
        description: "0 to 1",
        nullable: true,
      }),
    }),
  });

const QuestionShapeInterface = builder
  .interfaceRef<Question | History>("QuestionShape")
  .implement({
    fields: (t) => ({
      title: t.exposeString("title"),
      description: t.exposeString("description"),
      url: t.exposeString("url", {
        description:
          "Non-unique, a very small number of platforms have a page for more than one prediction",
      }),
      platform: t.field({
        type: PlatformObj,
        resolve: (parent) => parent.platform,
      }),
      timestamp: t.field({
        type: "Date",
        description:
          "Last timestamp at which metaforecast fetched the question",
        deprecationReason: "Renamed to `fetched`",
        resolve: (parent) => parent.fetched,
      }),
      fetched: t.field({
        type: "Date",
        description:
          "Last timestamp at which metaforecast fetched the question",
        resolve: (parent) => parent.fetched,
      }),
      fetchedStr: t.string({
        description:
          "Last timestamp at which metaforecast fetched the question, in ISO 8601 format",
        resolve: (parent) => parent.fetched.toISOString(),
      }),
      qualityIndicators: t.field({
        type: QualityIndicatorsObj,
        resolve: (parent) =>
          parent.qualityindicators as any as QualityIndicators,
      }),
      options: t.field({
        type: [ProbabilityOptionObj],
        resolve: ({ options }) => {
          if (!Array.isArray(options)) {
            return [];
          }
          return options as any[];
        },
      }),
    }),
  });

export const HistoryObj = builder.prismaObject("History", {
  findUnique: (history) => ({ pk: history.pk }),
  interfaces: [QuestionShapeInterface],
  fields: (t) => ({
    id: t.exposeID("pk", {
      description: "History items are identified by their integer ids",
    }),
    questionId: t.exposeID("id", {
      description: "Unique string which identifies the question",
    }),
  }),
});

export const QuestionObj = builder.prismaObject("Question", {
  findUnique: (question) => ({ id: question.id }),
  interfaces: [QuestionShapeInterface],
  fields: (t) => ({
    id: t.exposeID("id", {
      description: "Unique string which identifies the question",
    }),
    visualization: t.string({
      resolve: (parent) => (parent.extra as any)?.visualization, // used for guesstimate only, see searchGuesstimate.ts
      nullable: true,
    }),
    firstSeen: t.field({
      type: "Date",
      description: "First timestamp at which metaforecast fetched the question",
      resolve: (parent) => parent.firstSeen,
    }),
    firstSeenStr: t.string({
      description:
        "First timestamp at which metaforecast fetched the question, in ISO 8601 format",
      resolve: (parent) => parent.firstSeen.toISOString(),
    }),
    history: t.relation("history", {
      query: () => ({
        orderBy: {
          fetched: "asc",
        },
      }),
    }),
  }),
});

builder.queryField("questions", (t) =>
  t.prismaConnection(
    {
      type: "Question",
      cursor: "id",
      maxSize: 1000,
      args: {
        orderBy: t.arg({
          type: builder.enumType("QuestionsOrderBy", {
            values: ["FIRST_SEEN_DESC"] as const,
          }),
        }),
      },
      resolve: (query, parent, args) => {
        return prisma.question.findMany({
          ...query,
          ...(args.orderBy === "FIRST_SEEN_DESC"
            ? { orderBy: [{ firstSeen: "desc" }, { id: "asc" }] }
            : {}), // TODO - explicit default order?
        });
      },
    },
    {},
    {}
  )
);

builder.queryField("question", (t) =>
  t.field({
    type: QuestionObj,
    nullable: true,
    description: "Look up a single question by its id",
    args: {
      id: t.arg({ type: "ID", required: true }),
    },
    resolve: async (_, args) => {
      const parts = String(args.id).split("-");
      const [platform, id] = [parts[0], parts.slice(1).join("-")];
      if (platform === "guesstimate") {
        const q = await guesstimate.fetchQuestion(Number(id));
        return q;
      }
      return await prisma.question.findUnique({
        where: {
          id: String(args.id),
        },
      });
    },
  })
);



---
File: /src/graphql/schema/search.ts
---

import { estypes as ElasticTypes } from "@elastic/elasticsearch";

import { guesstimate } from "../../backend/platforms/guesstimate";
import { ElasticQuestion } from "../../backend/utils/elastic";
import { searchWithElastic } from "../../web/worker/searchWithElastic";
import { builder } from "../builder";
import { QuestionObj } from "./questions";

const SearchInput = builder.inputType("SearchInput", {
  fields: (t) => ({
    query: t.string({ required: true }),
    starsThreshold: t.int({
      description: "Minimum number of stars on a question",
    }),
    forecastsThreshold: t.int({
      description: "Minimum number of forecasts on a question",
    }),
    forecastingPlatforms: t.stringList({
      description: "List of platform ids to filter by",
    }),
    limit: t.int(),
  }),
});

builder.queryField("searchQuestions", (t) =>
  t.field({
    type: [QuestionObj],
    description:
      "Search for questions; uses Elasticsearch instead of the primary metaforecast database",
    args: {
      input: t.arg({ type: SearchInput, required: true }),
    },
    resolve: async (_, { input }) => {
      // defs
      const query = input.query === undefined ? "" : input.query;
      if (query === "") return [];
      const { forecastsThreshold, starsThreshold } = input;

      const platformsIncludeGuesstimate =
        input.forecastingPlatforms?.includes("guesstimate") &&
        (!starsThreshold || starsThreshold <= 1);

      // preparation
      const unawaitedElasticResponse = searchWithElastic({
        queryString: query,
        hitsPerPage: input.limit ?? 50,
        starsThreshold: starsThreshold ?? undefined,
        filterByPlatforms: input.forecastingPlatforms ?? undefined,
        forecastsThreshold: forecastsThreshold ?? undefined,
      });

      let results: ElasticQuestion[] = [];

      const toDocs = (hits: ElasticTypes.SearchHit<ElasticQuestion>[]) =>
        hits
          .map((hit) => hit._source)
          .filter((doc): doc is NonNullable<typeof doc> => !!doc);

      // consider the guesstimate and the non-guesstimate cases separately.
      if (platformsIncludeGuesstimate) {
        const [responsesNotGuesstimate, responsesGuesstimate] =
          await Promise.all([
            unawaitedElasticResponse,
            guesstimate.search(query),
          ]); // faster than two separate requests
        results = [...toDocs(responsesNotGuesstimate), ...responsesGuesstimate];
      } else {
        results = toDocs(await unawaitedElasticResponse);
      }

      return results.map((q) => ({
        ...q,
        fetched: new Date(q.fetched),
        firstSeen: new Date(q.firstSeen),
      }));
    },
  })
);



---
File: /src/graphql/builder.ts
---

import SchemaBuilder from "@pothos/core";
import PrismaPlugin from "@pothos/plugin-prisma";
import RelayPlugin from "@pothos/plugin-relay";

import { type PothosPrismaTypes, prisma } from "@quri/metaforecast-db";

export const builder = new SchemaBuilder<{
  PrismaTypes: PothosPrismaTypes;
  Scalars: {
    Date: {
      Input: Date;
      Output: Date;
    };
  };

  DefaultFieldNullability: false;
}>({
  plugins: [PrismaPlugin, RelayPlugin],
  prisma: {
    client: prisma,
  },
  defaultFieldNullability: false,
  relay: {
    clientMutationId: "omit",
    cursorType: "String",
    // these are required for some reason, though it's not documented and probably a bug
    brandLoadedObjects: undefined,
    encodeGlobalID: undefined,
    decodeGlobalID: undefined,
  },
});

builder.scalarType("Date", {
  description: "Date serialized as the Unix timestamp.",
  serialize: (d) => d.getTime() / 1000,
  parseValue: (d) => {
    return new Date(d as string); // not sure if this is correct, need to check
  },
});

builder.queryType({});
builder.mutationType({});



---
File: /src/graphql/print-schema.ts
---

import { writeFileSync } from "fs";
import { lexicographicSortSchema, printSchema } from "graphql";

import { schema } from "./schema/index.js";

const schemaAsString = printSchema(lexicographicSortSchema(schema));

writeFileSync("schema.graphql", schemaAsString);



---
File: /src/styles/main.css
---

@tailwind base;
@tailwind components;
@tailwind utilities;

.text-orange-400 {
  color: #ffac75;
}

html,
body {
  padding: 0;
  margin: 0;
  background-color: #ececf1;
  font-family:
    -apple-system,
    BlinkMacSystemFont,
    Segoe UI,
    Roboto,
    Oxygen,
    Ubuntu,
    Cantarell,
    Fira Sans,
    Droid Sans,
    Helvetica Neue,
    sans-serif;
}

html {
  overflow-y: scroll;
}

* {
  box-sizing: border-box;
}

h1 {
  font-size: 24px;
  font-weight: bold;
  margin-bottom: 10px;
  color: #1f2937;
}

h2 {
  font-size: 20px;
  font-weight: bold;
  margin-top: 10px;
  margin-bottom: 10px;
  color: #1f2937;
}

h3 {
  font-weight: bold;
  margin-top: 5px;
  margin-bottom: 5px;
  color: #1f2937;
}

a {
  color: blue;
  text-decoration: underline;
}

p,
ul {
  margin-bottom: 10px;
}

ul {
  list-style-type: square;
  margin-left: 20px;
}

ol {
  list-style: decimal;
  margin-left: 20px;
}



---
File: /src/web/common/BoxedLink.tsx
---

import { FC, PropsWithChildren } from "react";

import { FaExternalLinkAlt } from "react-icons/fa";

type Props = {
  url: string;
  size?: "normal" | "small";
};

export const BoxedLink: FC<PropsWithChildren<Props>> = ({
  url,
  size = "normal",
  children,
}) => (
  <a
    className={`inline-flex flex-nowrap items-center space-x-1 rounded-lg border-2 border-gray-400 px-2 py-1 text-xs text-black no-underline hover:bg-gray-100 md:text-lg ${
      size === "small" ? "text-sm" : ""
    }`}
    href={url}
    target="_blank"
  >
    <span>{children}</span>
    <FaExternalLinkAlt className="inline text-gray-400" />
  </a>
);



---
File: /src/web/common/Button.tsx
---

import { FC } from "react";

interface Props extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  size?: "small" | "normal";
}

export const Button: FC<Props> = ({ children, size = "normal", ...rest }) => {
  const padding = size === "normal" ? "px-5 py-4" : "px-3 py-2";
  return (
    <button
      {...rest}
      className={`cursor-pointer rounded-md bg-blue-500 text-white shadow hover:bg-blue-600 active:bg-gray-700 ${padding}`}
    >
      {children}
    </button>
  );
};



---
File: /src/web/common/Card.tsx
---

import { FC, PropsWithChildren } from "react";

const CardTitle: FC<PropsWithChildren> = ({ children }) => (
  <div className="text-lg font-medium text-gray-800">{children}</div>
);

interface Props {
  highlightOnHover?: boolean;
  large?: boolean;
}

type CardType = FC<PropsWithChildren<Props>> & {
  Title: typeof CardTitle;
};

export const Card: CardType = ({
  children,
  large = false,
  highlightOnHover = true,
}) => (
  <div
    className={`h-full rounded-md bg-white shadow ${
      highlightOnHover ? "hover:bg-gray-100" : ""
    } ${large ? "p-5 sm:p-10" : "px-4 py-3"}`}
  >
    {children}
  </div>
);

Card.Title = CardTitle;



---
File: /src/web/common/Collapsible.tsx
---

import { FC, useState } from "react";

import { FaCaretDown, FaCaretRight } from "react-icons/fa";

export const Collapsible: FC<{
  title: string;
  children: () => React.ReactElement | null;
}> = ({ title, children }) => {
  const [open, setOpen] = useState(false);

  const expand = (e: React.SyntheticEvent) => {
    e.preventDefault();
    setOpen(true);
  };

  const collapse = (e: React.SyntheticEvent) => {
    e.preventDefault();
    setOpen(false);
  };

  if (open) {
    return (
      <div>
        <a
          href="#"
          className="inline-flex items-center decoration-dashed"
          onClick={collapse}
        >
          {title} <FaCaretDown />
        </a>
        <div>{children()}</div>
      </div>
    );
  } else {
    return (
      <a
        href="#"
        className="inline-flex items-center decoration-dashed"
        onClick={expand}
      >
        {title} <FaCaretRight />
      </a>
    );
  }
};



---
File: /src/web/common/CopyParagraph.tsx
---

import { useState } from "react";

import { CopyToClipboard } from "react-copy-to-clipboard";

import { Button } from "./Button";

// https://stackoverflow.com/questions/39501289/in-reactjs-how-to-copy-text-to-clipboard

export const CopyParagraph: React.FC<{ text: string; buttonText: string }> = ({
  text,
  buttonText: initialButtonText,
}) => {
  const [buttonText, setButtonText] = useState(initialButtonText);
  const handleButton = () => {
    setButtonText("Copied");
    setTimeout(async () => {
      setButtonText(initialButtonText);
    }, 2000);
  };
  return (
    <div className="flex flex-col items-stretch">
      <p
        className="cursor-pointer rounded-md bg-gray-100 px-3 py-2 font-mono text-sm text-gray-700 shadow"
        onClick={(e) => {
          e.preventDefault();
          navigator.clipboard.writeText(text);
        }}
      >
        {text}
      </p>
      <CopyToClipboard text={text} onCopy={handleButton}>
        <Button size="small">{buttonText}</Button>
      </CopyToClipboard>
    </div>
  );
};



---
File: /src/web/common/CopyText.tsx
---

import { FC } from "react";
import { FaRegClipboard } from "react-icons/fa";

export const CopyText: FC<{
  text: string;
  displayText: string;
}> = ({ text, displayText }) => (
  <div
    className="flex cursor-pointer items-center justify-center space-x-3 rounded border border-blue-400 bg-transparent p-4 text-sm font-medium text-blue-400 hover:border-transparent hover:bg-blue-300 hover:text-white"
    onClick={(e) => {
      e.preventDefault();
      navigator.clipboard.writeText(text);
    }}
  >
    <span>{displayText}</span>
    <FaRegClipboard />
  </div>
);



---
File: /src/web/common/ErrorBoundary.tsx
---

"use client";
import React, { Component, ErrorInfo, PropsWithChildren } from "react";

// Error catcher
export class ErrorBoundary extends Component<
  PropsWithChildren,
  { error: any; errorInfo: any }
> {
  // https://reactjs.org/docs/error-boundaries.html
  constructor(props: {}) {
    super(props);
    this.state = { error: null, errorInfo: null };
  }

  override componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    // Catch errors in any components below and re-render with error message
    this.setState({
      error: error,
      errorInfo: errorInfo,
    });
    // You can also log error messages to an error reporting service here
  }

  override render() {
    if (this.state.errorInfo) {
      // Error path
      return (
        <div>
          <h2>Something went wrong. </h2>
          <details style={{ whiteSpace: "pre-wrap" }}>
            {
              "You should angrily tweet at @NunoSempere about this. or send an email to nuno.semperelh@gmail.com"
            }
            {this.state.error && this.state.error.toString()}
            <br />
            {this.state.errorInfo.componentStack}
          </details>
        </div>
      );
    }
    // Normally, just render children
    return this.props.children;
  }
}



---
File: /src/web/common/InfoBox.tsx
---

import { FC, PropsWithChildren } from "react";

export const InfoBox: FC<PropsWithChildren> = ({ children }) => (
  <p className="border border-transparent bg-gray-200 px-4 py-2 text-center text-gray-700">
    {children}
  </p>
);



---
File: /src/web/common/LineHeader.tsx
---

import { FC, PropsWithChildren } from "react";

export const LineHeader: FC<PropsWithChildren> = ({ children }) => (
  <h3 className="flex w-full items-center justify-center">
    <span aria-hidden="true" className="h-0.5 flex-grow rounded bg-gray-300" />
    <span className="text-md mx-3 text-center font-medium">{children}</span>
    <span aria-hidden="true" className="h-0.5 flex-grow rounded bg-gray-300" />
  </h3>
);



---
File: /src/web/common/MultiSelectPlatform.tsx
---

import chroma from "chroma-js";
import React, { FC } from "react";
import Select, { StylesConfig } from "react-select";

import { PlatformConfig } from "@/backend/types";

type Option = {
  value: string;
  label: string;
  color: string;
};

const colorStyles: StylesConfig<Option> = {
  control: (styles) => ({ ...styles, backgroundColor: "white" }),
  option: (styles, { data, isDisabled, isFocused, isSelected }) => {
    const color = chroma(data.color);

    return {
      ...styles,
      backgroundColor: isDisabled
        ? undefined
        : isSelected
          ? data.color
          : isFocused
            ? color.alpha(0.1).css()
            : undefined,
      color: isDisabled
        ? "#ccc"
        : isSelected
          ? chroma.contrast(color, "white") > 2
            ? "white"
            : "black"
          : data.color,
      cursor: isDisabled ? "not-allowed" : "default",

      ":active": {
        ...styles[":active"],
        backgroundColor: !isDisabled
          ? isSelected
            ? data.color
            : color.alpha(0.3).css()
          : undefined,
      },
    };
  },
  multiValue: (styles, { data }) => {
    const color = chroma(data.color);
    return {
      ...styles,
      backgroundColor: color.alpha(0.1).css(),
    };
  },
  multiValueLabel: (styles, { data }) => ({
    ...styles,
    color: data.color,
  }),
  multiValueRemove: (styles, { data }) => ({
    ...styles,
    color: data.color,
    ":hover": {
      backgroundColor: data.color,
      color: "white",
    },
  }),
};

type Props = {
  onChange: (platforms: string[]) => void;
  value: string[];
  platformsConfig: PlatformConfig[];
};

export const MultiSelectPlatform: FC<Props> = ({
  onChange,
  value,
  platformsConfig,
}) => {
  const options: Option[] = platformsConfig.map((platform) => ({
    value: platform.name,
    label: platform.label,
    color: platform.color,
  }));

  const id2option: { [k: string]: Option } = {};
  for (const option of options) id2option[option.value] = option;

  const selectValue = value.map((v) => id2option[v]).filter((v) => v);

  const onSelectChange = (newValue: readonly Option[]) => {
    onChange(newValue.map((o) => o.value));
  };

  return (
    <Select
      defaultValue={options}
      isMulti
      className="basic-multi-select w-full text-gray-700"
      onChange={onSelectChange}
      closeMenuOnSelect={false}
      options={options}
      value={selectValue}
      styles={colorStyles}
    />
  );
};



---
File: /src/web/common/Spinner.tsx
---

import { FC } from "react";

// via https://github.com/tailwindlabs/heroicons/issues/131#issuecomment-829192663
export const Spinner: FC = () => (
  <svg
    className="-ml-1 mr-3 h-5 w-5 animate-spin text-gray-500"
    fill="none"
    viewBox="0 0 24 24"
  >
    <circle
      className="opacity-25"
      cx="12"
      cy="12"
      r="10"
      stroke="currentColor"
      strokeWidth="4"
    ></circle>
    <path
      className="opacity-75"
      fill="currentColor"
      d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
    ></path>
  </svg>
);



---
File: /src/web/display/ButtonsForStars.tsx
---

import React from "react";

interface Props {
  onChange: (x: number) => void;
  value: number;
}

export const ButtonsForStars: React.FC<Props> = ({ onChange, value }) => {
  const onChangeInner = (buttonPressed: number) => {
    onChange(buttonPressed);
  };
  const setStyle = (buttonNumber: number) =>
    `flex row-span-1 col-start-${buttonNumber + 1} col-end-${
      buttonNumber + 2
    } items-center justify-center text-center${
      buttonNumber == value ? " text-blue-600" : ""
    }`;

  return (
    <div className="w-full flex-1 flex-col items-center justify-center">
      <div className="grid w-full grid-cols-6 grid-rows-1 content-center items-center text-gray-500">
        <div className={setStyle(0)}> </div>
        <button className={setStyle(1)} onClick={() => onChangeInner(1)}>
          1+ ★
        </button>
        <button className={setStyle(2)} onClick={() => onChangeInner(2)}>
          2+ ★
        </button>
        <button className={setStyle(3)} onClick={() => onChangeInner(3)}>
          3+ ★
        </button>
        <button className={setStyle(4)} onClick={() => onChangeInner(4)}>
          4+ ★
        </button>
        <div className={setStyle(5)}> </div>
      </div>
    </div>
  );
};



---
File: /src/web/display/DashboardCreator.tsx
---

import { ChangeEvent, EventHandler, FC, SyntheticEvent, useState } from "react";

import { Button } from "../common/Button";
import { InfoBox } from "../common/InfoBox";

const exampleInput = `{
  "title": "Random example",
  "description": "Just a random description of a random example",
  "ids": [ "metaculus-372", "goodjudgmentopen-2244", "metaculus-7550", "kalshi-09d060ee-b184-4167-b86b-d773e56b4162", "wildeford-5d1a04e1a8", "metaculus-2817" ],
  "creator": "Peter Parker"
}`;

interface Props {
  handleSubmit: (data: any) => Promise<void>;
}

export const DashboardCreator: FC<Props> = ({ handleSubmit }) => {
  const [value, setValue] = useState(exampleInput);
  const [acting, setActing] = useState(false);

  const handleChange = (event: ChangeEvent<HTMLTextAreaElement>) => {
    setValue(event.target.value);
  };

  const handleSubmitInner: EventHandler<SyntheticEvent> = async (event) => {
    event.preventDefault();

    try {
      const newData = JSON.parse(value);

      if (!newData || !newData.ids || newData.ids.length == 0) {
        throw Error("Not enough objects");
      } else {
        setActing(true);
        await handleSubmit(newData);
        setActing(false);
      }
    } catch (error) {
      setActing(false);
      const substituteText = `Error: ${
        error instanceof Error ? error.message : "Unknown"
      }

Try something like:
${exampleInput}

Your old input was: ${value}`;
      setValue(substituteText);
    }
  };

  return (
    <form onSubmit={handleSubmitInner}>
      <div className="flex max-w-2xl flex-col items-center space-y-5">
        <textarea value={value} onChange={handleChange} rows={8} cols={50} />
        <Button
          disabled={acting}
          onClick={acting ? undefined : handleSubmitInner}
        >
          {acting ? "Creating..." : "Create dashboard"}
        </Button>

        <InfoBox>
          You can find the necessary ids by toggling the advanced options in the
          search, or by using{" "}
          <a href="/api/graphql?query=%7B%0A++questions%28first%3A+100%29+%7B%0A++++pageInfo+%7B%0A++++++hasNextPage%0A++++++endCursor%0A++++%7D%0A++++edges+%7B%0A++++++node+%7B%0A++++++++id%0A++++++++title%0A++++++++url%0A++++++%7D%0A++++%7D%0A++%7D%0A%7D">
            GraphQL API
          </a>
        </InfoBox>
      </div>
    </form>
  );
};



---
File: /src/web/display/SliderElement.tsx
---

import { FC, useState } from "react";

import {
  GetHandleProps,
  GetTrackProps,
  Handles,
  Rail,
  Slider,
  SliderItem,
  Tracks,
} from "react-compound-slider";

// https://sghall.github.io/react-compound-slider/#/getting-started/tutorial

/* Definitions */

const sliderStyle = {
  // Give the slider some width
  position: "relative",
  width: "11em",
  height: 40,
  border: "5em",
};

const railStyle = {
  position: "absolute",
  width: "100%",
  height: 5,
  marginTop: 30,
  borderRadius: 5,
  backgroundColor: "lightgrey",
};

/* Support functions */
const Handle: FC<{
  handle: SliderItem;
  getHandleProps: GetHandleProps;
  displayFunction: (value: number) => string;
}> = ({ handle: { id, value, percent }, getHandleProps, displayFunction }) => {
  return (
    <>
      <div className="justify-center text-center text-xs text-gray-600">
        {displayFunction(value)}
      </div>
      <div
        style={{
          left: `${percent}%`,
          position: "absolute",
          marginLeft: -10,
          marginTop: 10,
          zIndex: 2,
          width: 15,
          height: 15,
          cursor: "pointer",
          borderRadius: "50%",
          backgroundColor: "#374151",
          color: "#374151",
        }}
        {...getHandleProps(id)}
      ></div>
    </>
  );
};

const Track: FC<{
  source: SliderItem;
  target: SliderItem;
  getTrackProps: GetTrackProps;
}> = ({ source, target, getTrackProps }) => {
  return (
    <div
      style={{
        position: "absolute",
        height: 5,
        zIndex: 1,
        marginTop: 15,
        backgroundColor: "#546C91",
        borderRadius: 5,
        cursor: "pointer",
        left: `${source.percent}%`,
        width: `${target.percent - source.percent}%`,
      }}
      {
        ...getTrackProps() /* this will set up events if you want it to be clickeable (optional) */
      }
    />
  );
};

type Props = {
  defaultValue: number;
  onChange: (value: number) => void;
  displayFunction: (value: number) => string;
};

/* Body */
export const SliderElement: FC<Props> = ({
  onChange,
  defaultValue,
  displayFunction,
}) => {
  const [value, setValue] = useState(defaultValue);

  return (
    <Slider
      rootStyle={
        sliderStyle /* inline styles for the outer div. Can also use className prop. */
      }
      domain={[0, 200]}
      values={[value]}
      onChange={(values) => {
        setValue(values[0]);
        onChange(values[0]);
      }}
    >
      <Rail>
        {({ getRailProps }) => <div style={railStyle} {...getRailProps()} />}
      </Rail>
      <Handles>
        {({ handles, getHandleProps }) => (
          <div>
            {handles.map((handle) => (
              <Handle
                key={handle.id}
                handle={handle}
                getHandleProps={getHandleProps}
                displayFunction={displayFunction}
              />
            ))}
          </div>
        )}
      </Handles>
      <Tracks right={false}>
        {({ tracks, getTrackProps }) => (
          <div>
            {tracks.map(({ id, source, target }) => (
              <Track
                key={id}
                source={source}
                target={target}
                getTrackProps={getTrackProps}
              />
            ))}
          </div>
        )}
      </Tracks>
    </Slider>
  );
};



---
File: /src/web/icons/Favicon.tsx
---

export const Favicon: React.FC<React.SVGAttributes<SVGElement>> = (props) => {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      className="favicon_svg__icon"
      viewBox="0 0 1024 1024"
      {...props}
    >
      <path d="M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372zm198.4-588.1a32 32 0 00-24.5.5L414.9 415 296.4 686c-3.6 8.2-3.6 17.5 0 25.7 3.4 7.8 9.7 13.9 17.7 17 3.8 1.5 7.7 2.2 11.7 2.2 4.4 0 8.7-.9 12.8-2.7l271-118.6 118.5-271a32.06 32.06 0 00-17.7-42.7zM576.8 534.4l26.2 26.2-42.4 42.4-26.2-26.2L380 644.4 447.5 490 422 464.4l42.4-42.4 25.5 25.5L644.4 380l-67.6 154.4zM464.4 422L422 464.4l25.5 25.6 86.9 86.8 26.2 26.2 42.4-42.4-26.2-26.2-86.8-86.9z" />
    </svg>
  );
};



---
File: /src/web/icons/index.ts
---

export { Favicon } from "./Favicon";
export { Logo } from "./Logo";
export { Logo2 } from "./Logo2";



---
File: /src/web/icons/Logo.tsx
---

export const Logo: React.FC<React.SVGAttributes<SVGElement>> = (props) => {
  return (
    <svg
      width={1333.333}
      height={1333.333}
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <defs>
        <linearGradient
          id="logo_svg__a"
          spreadMethod="pad"
          y2={-1.615}
          x2={0.581}
          y1={6.227}
          x1={0.29}
        >
          <stop stopColor="#f96703" offset={0} />
          <stop stopColor="#d52417" offset={1} />
        </linearGradient>
        <linearGradient
          id="logo_svg__c"
          spreadMethod="pad"
          y2={0.393}
          x2={0.501}
          y1={0.981}
          x1={0.407}
        >
          <stop stopColor="#f96703" offset={0} />
          <stop stopColor="#d52417" offset={1} />
        </linearGradient>
        <clipPath id="logo_svg__b" clipPathUnits="userSpaceOnUse">
          <path d="M-88.324 1308.851h1000v-1000h-1000v1000z" />
        </clipPath>
      </defs>
      <path
        fill="url(#logo_svg__a)"
        d="M306.451 665.044l10.144-5.539c2.183-.936 23.56-9.572 34.04 6.064.043.064.086.134.13.2-8.094-1.527-16.715-.07-24.184 4.203l-3.785 2.165-16.345-7.093z"
        transform="matrix(3.90084 0 0 -3.90084 -879.13 3184.77)"
      />
      <g
        clipPath="url(#logo_svg__b)"
        transform="matrix(3.90084 0 0 -3.90084 -879.13 3184.77)"
      >
        <path
          fill="#275372"
          d="M387.437 569.566a731.529 731.529 0 00-6.753 9.058c-17.83 24.184-21.54 29.216-76.768 32.8-23.29 1.511-49.7 14.663-65.768 23.982l-4.889-2.12c-5.648-2.452-6.038-9.876-.674-12.84L412.571 521c4.693-2.593 10.49-2.658 15.248-.173l11.924 6.23c-23.473 15.71-43.634 31.11-52.306 42.51"
        />
        <path
          fill="#0b92b5"
          d="M322.092 643.49c2.422 1.242 4.783 2.543 7.113 3.854-6.63.395-12.739 2.175-16.904 4.05l-.339.167-16.199 8.846-18.052-7.834c14.79-8.356 32.676-15.082 44.381-9.083"
        />
        <path
          fill="#275372"
          d="M351.51 675.297a23.584 23.584 0 016.632 3.31 805.778 805.778 0 012.86 5.526 746.317 746.317 0 003.055 5.907l-30.603-13.279c5.782-2.733 12.25-3.29 18.056-1.464"
        />
        <path
          fill="#056687"
          d="M407.302 613.099c-6.513 9.994-12.663 19.433-18.565 26.956-16.67 21.242-29.086 14.118-49.652 2.32-3.963-2.272-8.06-4.623-12.397-6.845-17.967-9.205-42.82 2.247-59.403 12.52l-18.5-8.028c15.34-8.4 37.07-18.342 55.792-19.557 57.64-3.74 64.45-10.143 84.005-36.671 2.026-2.746 4.218-5.722 6.673-8.947 8.5-11.172 29.525-26.888 53.831-42.91l17.96 9.384C441 561.41 422.613 589.6 407.301 613.099"
        />
        <path
          fill="#275372"
          d="M492.576 630.76c8.688-16.652 18.526-31.549 29.892-41.848a338.862 338.862 0 0113.502-11.584l25.81 13.484c2.69 1.405 2.63 5.066-.102 6.393l-69.102 33.554z"
        />
        <path
          fill="#0b92b5"
          d="M434.228 649.515c-2.202 4.23-4.451 8.55-6.711 12.835a792.193 792.193 0 01-7.435 13.805c-9.608 17.376-18.756 31.655-24.776 33.193-4.062 1.037-7.909-1.364-11.61-5.67-1.77-2.06-3.507-4.555-5.218-7.321-1.536-2.485-3.052-5.184-4.553-7.984-1.434-2.675-2.855-5.44-4.267-8.187a596.652 596.652 0 00-3.817-7.347c-2.082-3.921-4.225-7.727-6.455-11.155 11.999 2.782 24.318.023 37.083-16.241 6.151-7.837 12.405-17.438 19.03-27.603 15.499-23.786 34.263-52.513 60.679-71.747l19.23 10.046c-22.38 18.849-42.936 58.323-61.18 93.376"
        />
      </g>
      <path
        fill="url(#logo_svg__c)"
        d="M389.886 718.41c2.472.467 5.105.406 7.938-.316 10.785-2.755 21.255-19.585 36.885-49.042 2.278-4.294 4.667-8.856 7.182-13.682l.972-1.866c18.612-35.76 39.69-76.237 61.532-92.672l22.638 11.828a342.66 342.66 0 00-11.235 9.721c-14.746 13.364-26.87 33.471-37.227 55.178a441.106 441.106 0 00-5.976 13.097c-6.279 14.352-11.886 28.948-17.048 42.391-11.444 29.808-24.926 78.95-34.89 79h-.033c-12.204.002-22.24-34.256-30.738-53.638"
        transform="matrix(3.90084 0 0 -3.90084 -879.13 3184.77)"
      />
    </svg>
  );
};



---
File: /src/web/icons/Logo2.tsx
---

export const Logo2: React.FC<React.SVGAttributes<SVGElement>> = (props) => {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="1333pt"
      height="1333pt"
      viewBox="0 0 1333 1333"
      {...props}
    >
      <defs>
        <linearGradient
          id="logo2_svg__a"
          gradientUnits="userSpaceOnUse"
          x1={0.29}
          y1={6.227}
          x2={0.581}
          y2={-1.615}
          gradientTransform="matrix(172.85547 0 0 -61.6875 316.29 624.559)"
        >
          <stop offset={0} stopColor="#f96703" />
          <stop offset={1} stopColor="#d52417" />
        </linearGradient>
        <linearGradient
          id="logo2_svg__b"
          gradientUnits="userSpaceOnUse"
          x1={0.407}
          y1={0.981}
          x2={0.501}
          y2={0.393}
          gradientTransform="matrix(534.98828 0 0 -823.91406 641.754 997.05)"
        >
          <stop offset={0} stopColor="#f96703" />
          <stop offset={1} stopColor="#d52417" />
        </linearGradient>
      </defs>
      <path
        d="M316.29 590.54l39.57 21.605c8.515 3.652 91.898 37.34 132.78-23.657.169-.246.337-.52.505-.773-31.567 5.953-65.2.273-94.332-16.399l-14.766-8.445zm0 0"
        fill="url(#logo2_svg__a)"
      />
      <path
        d="M632.2 962.984c-9.684-12.742-18.348-24.488-26.34-35.336-69.555-94.336-84.028-113.964-299.462-127.945-90.851-5.894-193.875-57.2-256.55-93.55l-19.07 8.273c-22.032 9.558-23.555 38.52-2.63 50.082l702.094 387.922c18.309 10.117 40.922 10.37 59.48.675l46.516-24.3c-91.566-61.285-170.21-121.356-204.039-165.82"
        fill="#275372"
      />
      <path
        d="M377.3 674.617c9.45-4.844 18.657-9.918 27.747-15.031-25.867-1.543-49.692-8.484-65.938-15.797l-1.324-.656-63.191-34.504-70.418 30.558c57.691 32.594 127.465 58.833 173.125 35.43"
        fill="#0b92b5"
      />
      <path
        d="M492.055 550.543c9.37-2.945 17.98-7.293 25.87-12.906 3.75-7.164 7.47-14.39 11.153-21.563 3.95-7.691 7.914-15.402 11.922-23.043l-119.379 51.801c22.555 10.66 47.781 12.832 70.434 5.711"
        fill="#275372"
      />
      <path
        d="M709.691 793.172c-25.406-38.985-49.394-75.805-72.418-105.152-65.03-82.864-113.46-55.07-193.687-9.055-15.457 8.867-31.441 18.039-48.356 26.707-70.085 35.906-167.039-8.766-231.722-48.84L91.34 688.148c59.84 32.766 144.605 71.551 217.637 76.29 224.84 14.585 251.41 39.566 327.691 143.046 7.902 10.711 16.453 22.32 26.031 34.903 33.153 43.578 115.172 104.883 209.985 167.379l70.054-36.602c-101.593-78.367-173.316-188.328-233.047-279.992"
        fill="#056687"
      />
      <path
        d="M1042.328 724.277c33.89 64.953 72.27 123.067 116.606 163.243 17.191 15.582 34.828 30.644 52.668 45.183l100.683-52.598c10.492-5.48 10.258-19.761-.398-24.937zm0 0"
        fill="#275372"
      />
      <path
        d="M814.723 651.117c-8.59-16.504-17.36-33.351-26.176-50.066-9.668-18.332-19.395-36.48-29.004-53.852-37.48-67.781-73.164-123.48-96.648-129.48-15.844-4.047-30.852 5.32-45.29 22.117-6.902 8.031-13.68 17.77-20.351 28.559-5.992 9.69-11.906 20.222-17.762 31.144-5.594 10.434-11.137 21.215-16.644 31.934-4.891 9.527-9.848 19.168-14.891 28.66-8.121 15.297-16.48 30.144-25.18 43.515 46.805-10.851 94.86-.09 144.657 63.352 23.992 30.574 48.386 68.023 74.23 107.676 60.461 92.785 133.656 204.844 236.7 279.875l75.015-39.188c-87.3-73.527-167.488-227.511-238.656-364.246"
        fill="#0b92b5"
      />
      <path
        d="M641.754 382.371c9.644-1.828 19.914-1.59 30.965 1.227 42.07 10.746 82.914 76.398 143.883 191.304 8.886 16.75 18.207 34.547 28.015 53.371 1.266 2.426 2.512 4.82 3.793 7.282 72.602 139.492 154.824 297.386 240.028 361.496l88.304-46.137c-14.816-12.3-29.472-24.914-43.824-37.922-57.523-52.129-104.816-130.562-145.219-215.238-8.031-16.836-15.793-33.91-23.308-51.09-24.496-55.984-46.368-112.922-66.504-165.36-44.64-116.277-97.23-307.972-136.098-308.167h-.129c-47.61-.008-86.762 133.625-119.906 209.234"
        fill="url(#logo2_svg__b)"
      />
    </svg>
  );
};



---
File: /src/web/questions/components/HistoryChart/index.tsx
---

"use client";
import React, { FC, useMemo, useState } from "react";

import dynamic from "next/dynamic";

import { QuestionWithHistoryFragment } from "../../../fragments.generated";
import { Props as InnerChartProps } from "./InnerChart"; // hopefully doesn't import code, just types - need to check
import { InnerChartPlaceholder } from "./InnerChartPlaceholder";
import { Legend } from "./Legend";
import { buildChartData, chartColors } from "./utils";

const InnerChart = dynamic<InnerChartProps>(
  () => import("./InnerChart").then((mod) => mod.InnerChart),
  { ssr: false, loading: () => <InnerChartPlaceholder /> }
);

interface Props {
  question: QuestionWithHistoryFragment;
}

export const HistoryChart: FC<Props> = ({ question }) => {
  // maybe use context instead?
  const [highlight, setHighlight] = useState<number | undefined>(undefined);

  const data = useMemo(() => buildChartData(question), [question]);

  return (
    <div className="flex items-center space-y-4 sm:flex-row sm:space-y-0">
      <InnerChart data={data} highlight={highlight} />
      <Legend
        items={data.seriesNames.map((name, i) => ({
          name,
          color: chartColors[i],
        }))}
        setHighlight={setHighlight}
      />
    </div>
  );
};



---
File: /src/web/questions/components/HistoryChart/InnerChart.tsx
---

import { FC } from "react";

import { differenceInDays, format } from "date-fns";
import {
  VictoryArea,
  VictoryAxis,
  VictoryChart,
  VictoryGroup,
  VictoryLabel,
  VictoryLine,
  VictoryScatter,
  VictoryTheme,
  VictoryTooltip,
  VictoryVoronoiContainer,
} from "victory";

import { chartColors, ChartData, ChartSeries, goldenRatio } from "./utils";

const height = 200;
const width = 200 * goldenRatio;
let dateFormat = "dd/MM/yy"; // "yyyy-MM-dd" // "MMM do yy"

// can't be replaced with React component, VictoryChart requires VictoryGroup elements to be immediate children
const getVictoryGroup = ({
  data,
  i,
  highlight,
  isBinary,
}: {
  data: ChartSeries;
  i: number;
  highlight?: boolean;
  isBinary?: boolean;
}) => {
  return (
    <VictoryGroup color={chartColors[i] || "darkgray"} data={data} key={i}>
      <VictoryLine
        name={`line-${i}`}
        style={{
          data: {
            // strokeOpacity: highlight ?  1 : 0.5,
            strokeOpacity: highlight && !isBinary ? 0.8 : 0.6,
            strokeWidth: highlight && !isBinary ? 2.5 : 1.5,
          },
        }}
      />
      {isBinary ? (
        <VictoryArea
          standalone={false}
          style={{
            data: { fill: chartColors[i], fillOpacity: 0.1, strokeOpacity: 0 },
          }}
          data={data}
        />
      ) : null}

      <VictoryScatter
        name={`scatter-${i}`}
        size={({ active }) => (active || highlight ? 0 : 0)} //(active || highlight ? 3.75 : 3)}
      />
    </VictoryGroup>
  );
};

export type Props = {
  data: ChartData;
  highlight: number | undefined;
};

export const InnerChart: FC<Props> = ({
  data: { maxProbability, seriesList, minDate, maxDate },
  highlight,
}) => {
  const domainMax =
    maxProbability < 0.5 ? Math.round(10 * (maxProbability + 0.05)) / 10 : 1;
  const padding = {
    top: 12,
    bottom: 33,
    left: 30,
    right: 17,
  };

  const isBinary = seriesList.length == 1;
  console.log(isBinary);

  return (
    <VictoryChart
      domainPadding={{ x: 0 }}
      padding={padding}
      theme={VictoryTheme.material}
      height={height}
      width={width}
      containerComponent={
        <VictoryVoronoiContainer
          labels={() => "Not shown"}
          labelComponent={
            <VictoryTooltip
              constrainToVisibleArea
              pointerLength={0}
              dy={-12}
              labelComponent={
                <VictoryLabel
                  style={[
                    {
                      fontSize: 10,
                      fill: "black",
                      strokeWidth: 0.05,
                    },
                    {
                      fontSize: 10,
                      fill: "#777",
                      strokeWidth: 0.05,
                    },
                  ]}
                />
              }
              text={({ datum }) =>
                `${datum.name}: ${Math.round(datum.y * 100)}%\n${format(
                  datum.x,
                  dateFormat
                )}`
              }
              style={{
                fontSize: 10, // needs to be set here and not just in labelComponent for text size calculations
                fontFamily:
                  '"Gill Sans", "Gill Sans MT", "Ser­avek", "Trebuchet MS", sans-serif',
                // default font family from Victory, need to be specified explicitly for some reason, otherwise text size gets miscalculated
              }}
              flyoutStyle={{
                stroke: "#999",
                fill: "white",
              }}
              cornerRadius={4}
              flyoutPadding={{ top: 4, bottom: 4, left: 10, right: 10 }}
            />
          }
          radius={20}
          voronoiBlacklist={
            [...Array(seriesList.length).keys()].map((i) => `line-${i}`)
            // see: https://github.com/FormidableLabs/victory/issues/545
          }
        />
      }
      scale={{
        x: "time",
        y: "linear",
      }}
      domain={{
        x: [minDate, maxDate],
        y: [0, domainMax],
      }}
    >
      {
        // Note: axis is not in fact unaligned. Fetchers are at ~12:00
        // whereas the date is at the beginning of the day
        // however, it still doesn't look very pretty.
      }
      <VictoryAxis
        tickCount={Math.min(7, differenceInDays(maxDate, minDate) + 1)}
        style={{
          grid: { strokeWidth: 0.5 },
        }}
        tickLabelComponent={
          <VictoryLabel
            dx={-10}
            dy={0}
            angle={-30}
            style={{ fontSize: 9, fill: "#777" }}
          />
        }
        scale={{ x: "time" }}
        tickFormat={(t: Date) => format(t, dateFormat)}
      />
      <VictoryAxis
        dependentAxis
        style={{
          grid: { stroke: "#D3D3D3", strokeWidth: 0.5 },
        }}
        tickLabelComponent={
          <VictoryLabel dy={0} dx={5} style={{ fontSize: 9, fill: "#777" }} />
        }
        // tickFormat specifies how ticks should be displayed
        tickFormat={(x: number) => `${x * 100}%`}
      />

      {[...Array(seriesList.length).keys()]
        .reverse() // affects svg render order, we want to render largest datasets on top of others
        //.filter((i) => i !== highlight)
        .map((i) =>
          getVictoryGroup({
            data: seriesList[i],
            i,
            highlight: i == highlight, // false
            isBinary: isBinary,
          })
        )}

      {
        // note: this produces an annoying change of color effect
        /*
        highlight === undefined
          ? null
          : // render highlighted series on top of everything else
            getVictoryGroup({
              data: seriesList[highlight],
              i: highlight,
              highlight: true,
            })
            */
      }
    </VictoryChart>
  );
};



---
File: /src/web/questions/components/HistoryChart/InnerChartPlaceholder.tsx
---

import { height, width } from "./utils";

export const InnerChartPlaceholder: React.FC = () => {
  return (
    <svg
      width={width}
      height={height}
      style={{ width: "100%", height: "100%" }}
    />
  );
};



---
File: /src/web/questions/components/HistoryChart/Legend.tsx
---

import { Tooltip } from "@quri/ui";

type Item = {
  name: string;
  color: string;
};

const LegendItem: React.FC<{ item: Item; onHighlight: () => void }> = ({
  item,
  onHighlight,
}) => {
  return (
    <Tooltip
      render={() => (
        <div className="rounded border border-gray-300 bg-white p-2 text-xs">
          {item.name}
        </div>
      )}
    >
      <div>
        <div
          className="flex cursor-pointer items-center"
          onMouseOver={() => onHighlight()}
        >
          <svg className="mt-1 shrink-0" height="10" width="16">
            <circle cx="4" cy="4" r="4" fill={item.color} />
          </svg>
          <div className="sm:max-w-160 text-xs sm:overflow-hidden sm:text-ellipsis sm:whitespace-nowrap sm:text-sm">
            {item.name}
          </div>
        </div>
      </div>
    </Tooltip>
  );
};

export const Legend: React.FC<{
  items: { name: string; color: string }[];
  setHighlight: (i: number | undefined) => void;
}> = ({ items, setHighlight }) => {
  return (
    <div className="space-y-2" onMouseLeave={() => setHighlight(undefined)}>
      {items.map((item, i) => (
        <LegendItem
          key={item.name}
          item={item}
          onHighlight={() => setHighlight(i)}
        />
      ))}
    </div>
  );
};



---
File: /src/web/questions/components/HistoryChart/utils.ts
---

import { addDays, startOfDay, startOfToday, startOfTomorrow } from "date-fns";

import { isFullQuestionOption } from "../../../../common/types";
import { QuestionWithHistoryFragment } from "../../../fragments.generated";
import { isQuestionBinary } from "../../../utils";

export type ChartSeries = { x: Date; y: number; name: string }[];

export const MAX_LINES = 5;

// number of colors should match MAX_LINES
// colors are taken from tailwind, https://tailwindcss.com/docs/customizing-colors
export const chartColors = [
  "#0284C7", // sky-600
  "#DC2626", // red-600
  "#15803D", // green-700
  "#7E22CE", // purple-700
  "#F59E0B", // amber-500
];

export const goldenRatio = (1 + Math.sqrt(5)) / 2;
// used both for chart and for ssr placeholder
export const width = 750;
export const height = width / goldenRatio;

export type ChartData = {
  seriesList: ChartSeries[];
  seriesNames: string[];
  maxProbability: number;
  minDate: Date;
  maxDate: Date;
};

export const buildChartData = (
  question: QuestionWithHistoryFragment
): ChartData => {
  let seriesNames = question.options
    .filter(isFullQuestionOption)
    .sort((a, b) => {
      if (a.probability > b.probability) {
        return -1;
      } else if (a.probability < b.probability) {
        return 1;
      }
      return a.name < b.name ? -1 : 1; // needed for stable sorting - otherwise it's possible to get order mismatch in SSR vs client-side
    })
    .map((o) => o.name)
    .slice(0, MAX_LINES);

  const isBinary = isQuestionBinary(question);
  if (isBinary) {
    seriesNames = ["Yes"];
  }

  const nameToIndex = Object.fromEntries(
    seriesNames.map((name, i) => [name, i])
  );
  let seriesList: ChartSeries[] = [...Array(seriesNames.length)].map((x) => []);

  const sortedHistory = question.history.sort((a, b) =>
    a.fetched < b.fetched ? -1 : 1
  );

  {
    let previousDate = -Infinity;
    for (const item of sortedHistory) {
      if (item.fetched - previousDate < 12 * 60 * 60) {
        continue;
      }
      const date = new Date(item.fetched * 1000);

      for (const option of item.options) {
        if (option.name == null || option.probability == null) {
          continue;
        }
        const idx = nameToIndex[option.name];
        if (idx === undefined) {
          continue;
        }
        const result = {
          x: date,
          y: option.probability,
          name: option.name,
        };
        seriesList[idx].push(result);
      }
      previousDate = item.fetched;
    }
  }

  let maxProbability = 0;
  for (const dataSet of seriesList) {
    for (const item of dataSet) {
      maxProbability = Math.max(maxProbability, item.y);
    }
  }

  const minDate = sortedHistory.length
    ? startOfDay(new Date(sortedHistory[0].fetched * 1000))
    : startOfToday();
  const maxDate = sortedHistory.length
    ? addDays(
        startOfDay(
          new Date(sortedHistory[sortedHistory.length - 1].fetched * 1000)
        ),
        1
      )
    : startOfTomorrow();

  return {
    seriesList,
    seriesNames,
    maxProbability,
    minDate,
    maxDate,
  };
};



---
File: /src/web/questions/components/QuestionCard/index.tsx
---

import Link from "next/link";
import { FC, ReactElement, ReactNode } from "react";
import { FaExpand } from "react-icons/fa";
import ReactMarkdown from "react-markdown";
import rehypeExternalLinks from "rehype-external-links";

import { Card } from "../../../common/Card";
import { CopyText } from "../../../common/CopyText";
import { QuestionFragment } from "../../../fragments.generated";
import { cleanText, isQuestionBinary } from "../../../utils";
import { QuestionOptions } from "../QuestionOptions";
import { QuestionFooter } from "./QuestionFooter";

function truncateText(length: number, text: string): string {
  if (!text) {
    return "";
  }
  if (text.length <= length) {
    return text;
  }
  const breakpoints = " .!?";
  let lastLetter;
  let lastIndex;
  for (let index = length; index > 0; index--) {
    const letter = text[index];
    if (breakpoints.includes(letter)) {
      lastLetter = letter;
      lastIndex = index;
      break;
    }
  }
  let truncatedText =
    text.slice(0, lastIndex) + (lastLetter != "." ? "..." : "..");
  return truncatedText;
}

// Auxiliary components

const DisplayMarkdown: FC<{ description: string }> = ({ description }) => {
  const formatted = truncateText(250, cleanText(description));
  // overflow-hidden overflow-ellipsis h-24
  return formatted === "" ? null : (
    <div className="overflow-clip font-normal">
      <ReactMarkdown
        rehypePlugins={[[rehypeExternalLinks, { target: "_blank" }]]}
      >
        {formatted}
      </ReactMarkdown>
    </div>
  );
};

const LastUpdated: FC<{ timestamp: Date }> = ({ timestamp }) => (
  <div className="flex items-center">
    <svg className="mt-1" height="10" width="16">
      <circle cx="4" cy="4" r="4" fill="rgb(29, 78, 216)" />
    </svg>
    <span className="text-gray-600">
      Last updated:{" "}
      {timestamp ? timestamp.toISOString().slice(0, 10) : "unknown"}
    </span>
  </div>
);

// Main component

interface Props {
  container?: (children: ReactNode) => ReactElement;
  question: QuestionFragment;
  showTimeStamp: boolean;
  expandFooterToFullWidth: boolean;
  showIdToggle?: boolean;
  showExpandButton?: boolean;
}

export const QuestionCard: FC<Props> = ({
  container = (children) => <Card>{children}</Card>,
  question,
  showTimeStamp,
  expandFooterToFullWidth,
  showIdToggle,
  showExpandButton = true,
}) => {
  const { options } = question;
  const lastUpdated = new Date(question.fetched * 1000);

  const isBinary = isQuestionBinary(question);

  return container(
    <div className="flex h-full flex-col space-y-4">
      <div className="flex-grow space-y-4">
        {showIdToggle ? (
          <div className="mx-10">
            <CopyText text={question.id} displayText={`[${question.id}]`} />
          </div>
        ) : null}
        <div>
          {showExpandButton ? (
            <Link
              href={`/questions/${question.id}`}
              passHref
              className="float-right ml-2 mt-1.5 block"
            >
              <FaExpand
                size="18"
                className="text-gray-400 hover:text-gray-700"
              />
            </Link>
          ) : null}
          <Card.Title>
            <a
              className="text-black no-underline"
              href={question.url}
              target="_blank"
            >
              {question.title}
            </a>
          </Card.Title>
        </div>
        <div className={isBinary ? "flex justify-between" : "space-y-4"}>
          <QuestionOptions question={question} maxNumOptions={5} />
          <div className={`hidden ${showTimeStamp ? "sm:block" : ""}`}>
            <LastUpdated timestamp={lastUpdated} />
          </div>
        </div>

        {question.platform.id !== "guesstimate" && options.length < 3 && (
          <div className="text-gray-500">
            <DisplayMarkdown description={question.description} />
          </div>
        )}

        {question.platform.id === "guesstimate" && question.visualization && (
          <img
            className="rounded-sm"
            src={question.visualization}
            alt="Guesstimate Screenshot"
          />
        )}
      </div>
      <div
        className={`sm:hidden ${!showTimeStamp ? "hidden" : ""} self-center`}
      >
        {/* This one is exclusively for mobile*/}
        <LastUpdated timestamp={lastUpdated} />
      </div>
      <div className="w-full">
        <div className="mb-2 mt-1">
          <QuestionFooter
            question={question}
            expandFooterToFullWidth={expandFooterToFullWidth}
          />
        </div>
      </div>
    </div>
  );
};



---
File: /src/web/questions/components/QuestionCard/QuestionFooter.tsx
---

import { FC } from "react";

import { QuestionFragment } from "../../../fragments.generated";
import { Stars } from "../Stars";

type QualityIndicator = QuestionFragment["qualityIndicators"];
type IndicatorName = keyof QualityIndicator;

// this duplication can probably be simplified with typescript magic, but this is good enough for now
export type UsedIndicatorName =
  // | "numForecasts"
  // | "stars"
  | "volume"
  | "numForecasters"
  | "spread"
  | "sharesVolume"
  | "liquidity"
  | "tradeVolume"
  | "openInterest";

export const qualityIndicatorLabels: { [k in UsedIndicatorName]: string } = {
  // numForecasts: "Number of forecasts",
  // stars: "Stars",
  // yesBid: "Yes bid",
  // yesAsk: "Yes ask",
  volume: "Volume",
  numForecasters: "Forecasters",
  spread: "Spread",
  sharesVolume: "Shares vol.",
  liquidity: "Liquidity",
  tradeVolume: "Volume",
  openInterest: "Interest",
};

const isUsedIndicatorName = (name: string): name is UsedIndicatorName => {
  return name in qualityIndicatorLabels;
};

const formatNumber = (num: number) => {
  if (num < 1000) {
    return num.toFixed(0);
  } else if (num < 10000) {
    return (num / 1000).toFixed(1) + "k";
  } else {
    return (num / 1000).toFixed(0) + "k";
  }
};

/* Display functions*/

const getPercentageSymbolIfNeeded = ({
  indicator,
  platform,
}: {
  indicator: UsedIndicatorName;
  platform: string;
}) => {
  const indicatorsWhichNeedPercentageSymbol: IndicatorName[] = ["spread"];
  if (indicatorsWhichNeedPercentageSymbol.includes(indicator)) {
    return "%";
  } else {
    return "";
  }
};

const getCurrencySymbolIfNeeded = ({
  indicator,
  platform,
}: {
  indicator: UsedIndicatorName;
  platform: string;
}) => {
  const indicatorsWhichNeedCurrencySymbol: IndicatorName[] = [
    "volume",
    "tradeVolume",
    "openInterest",
    "liquidity",
  ];
  const dollarPlatforms = ["predictit", "kalshi", "polymarket", "insight"];
  const manaPlatforms = ["manifold"];
  if (indicatorsWhichNeedCurrencySymbol.includes(indicator)) {
    if (dollarPlatforms.includes(platform)) {
      return "$";
    } else if (manaPlatforms.includes(platform)) {
      return "M";
    } else {
      return "£";
    }
  } else {
    return "";
  }
};

const FirstQualityIndicator: React.FC<{
  question: QuestionFragment;
}> = ({ question }) => {
  if (question.qualityIndicators.numForecasts) {
    return (
      <div className="flex">
        <span>Forecasts:</span>&nbsp;
        <span className="font-bold">
          {Number(question.qualityIndicators.numForecasts).toFixed(0)}
        </span>
      </div>
    );
  } else {
    return null;
  }
};

export const formatIndicatorValue = (
  value: number,
  indicator: UsedIndicatorName,
  platform: string
): string => {
  return `${getCurrencySymbolIfNeeded({
    indicator,
    platform: platform,
  })}${formatNumber(value)}${getPercentageSymbolIfNeeded({
    indicator,
    platform: platform,
  })}`;
};

const QualityIndicatorsList: FC<{
  question: QuestionFragment;
}> = ({ question }) => {
  return (
    <div className="text-sm">
      <FirstQualityIndicator question={question} />
      {Object.entries(question.qualityIndicators).map(
        ([indicator, value], i) => {
          if (!isUsedIndicatorName(indicator)) return;
          const indicatorLabel = qualityIndicatorLabels[indicator];
          if (!indicatorLabel || value === null) return;

          return (
            <div key={indicator}>
              <span>{indicatorLabel}:</span>&nbsp;
              <span className="font-bold">
                {formatIndicatorValue(
                  Number(value),
                  indicator,
                  question.platform.id
                )}
              </span>
            </div>
          );
        }
      )}
    </div>
  );
};

export const QuestionFooter: FC<{
  question: QuestionFragment;
  expandFooterToFullWidth: boolean;
}> = ({ question, expandFooterToFullWidth }) => {
  return (
    <div
      className={`grid grid-cols-3 ${
        expandFooterToFullWidth ? "justify-between" : ""
      } text-gray-500`}
    >
      <div className="self-center">
        <Stars num={question.qualityIndicators.stars} />
      </div>
      <div
        className={`${
          expandFooterToFullWidth ? "place-self-center" : "self-center"
        } col-span-1 font-bold`}
      >
        {question.platform.label
          .replace("Good Judgment Open", "GJOpen")
          .replace("Insight Prediction", "Insight")
          .replace(/ /g, "\u00a0")}
      </div>
      <div
        className={`${
          expandFooterToFullWidth
            ? "mr-4 justify-self-end"
            : "justify-self-center"
        } col-span-1`}
      >
        <QualityIndicatorsList question={question} />
      </div>
    </div>
  );
};



---
File: /src/web/questions/components/CaptureQuestion.tsx
---

"use client";
import domtoimage from "dom-to-image"; // https://github.com/tsayen/dom-to-image
import { Resizable } from "re-resizable";
import { FC, PropsWithChildren, useEffect, useRef, useState } from "react";

import { Button } from "../../common/Button";
import { CopyParagraph } from "../../common/CopyParagraph";
import { QuestionFragment } from "../../fragments.generated";
import { uploadToImgur } from "../../worker/uploadToImgur";
import { QuestionCard } from "./QuestionCard";

const domToImageWrapper = async (node: HTMLDivElement) => {
  const scale = 3; // Increase for better quality
  const style = {
    transform: "scale(" + scale + ")",
    transformOrigin: "top left",
    width: node.offsetWidth + "px",
    height: node.offsetHeight + "px",
  };
  const param = {
    height: node.offsetHeight * scale,
    width: node.offsetWidth * scale,
    quality: 1,
    style,
  };
  const image = await domtoimage.toPng(node, param);
  return image;
};

const ImageSource: FC<{ question: QuestionFragment; imgSrc: string }> = ({
  question,
  imgSrc,
}) => {
  if (!imgSrc) {
    return null;
  }

  const html = `<a href="${question.url}" target="_blank"><img src="${imgSrc}" alt="Metaforecast.org snapshot of ''${question.title}'', from ${question.platform.label}"></a>`;
  const markdown = `[![](${imgSrc})](${question.url})`;

  return (
    <div className="space-y-4">
      <CopyParagraph text={markdown} buttonText="Copy markdown" />
      <CopyParagraph text={html} buttonText="Copy HTML" />
    </div>
  );
};

const generateMetaculusIframeURL = (question: QuestionFragment) => {
  let parts = question.url.replace("questions", "questions/embed").split("/");
  parts.pop();
  parts.pop();
  const iframeURL = parts.join("/");
  return iframeURL;
};

const generateMetaculusIframeHTML = (question: QuestionFragment) => {
  const iframeURL = generateMetaculusIframeURL(question);
  return `<iframe src="${iframeURL}" height="400" width="600"/>`;
};

const MetaculusEmbed: React.FC<{ question: QuestionFragment }> = ({
  question,
}) => {
  if (question.platform.id !== "metaculus") return null;

  const iframeURL = generateMetaculusIframeURL(question);
  return <iframe className="h-80 w-full" src={iframeURL} />;
};

const MetaculusSource: FC<{
  question: QuestionFragment;
}> = ({ question }) => {
  if (question.platform.id !== "metaculus") return null;

  return (
    <CopyParagraph
      text={generateMetaculusIframeHTML(question)}
      buttonText="Copy HTML"
    />
  );
};

const GrayContainer: FC<PropsWithChildren<{ title: string }>> = ({
  title,
  children,
}) => (
  <div className="space-y-1 bg-gray-100 p-2">
    <div className="text-xs font-bold uppercase tracking-wide text-gray-600">
      {title}:
    </div>
    <div>{children}</div>
  </div>
);

interface Props {
  question: QuestionFragment;
}

export const CaptureQuestion: React.FC<Props> = ({ question }) => {
  const [imgSrc, setImgSrc] = useState<string | null>(null);

  useEffect(() => {
    setImgSrc(null);
  }, [question]);

  const containerRef = useRef<HTMLDivElement | null>(null);

  const initialMainButtonText = "Capture image and generate code";
  const [mainButtonText, setMainButtonText] = useState(initialMainButtonText);

  const exportAsPictureAndCode = async () => {
    if (!containerRef.current) {
      return;
    }
    try {
      const dataUrl = await domToImageWrapper(containerRef.current);
      const imgurUrl = await uploadToImgur(dataUrl);
      setImgSrc(imgurUrl);
      setMainButtonText("Done!");
      setTimeout(async () => {
        setMainButtonText(initialMainButtonText);
      }, 2000);
    } catch (error) {
      console.error("oops, something went wrong!", error);
    }
  };

  const onCaptureButtonClick = async () => {
    setMainButtonText("Processing...");
    setImgSrc(null);
    await exportAsPictureAndCode();
  };

  if (imgSrc) {
    return (
      <div className="space-y-4">
        <GrayContainer title="Generated image">
          <a href={imgSrc} target="_blank">
            <img src={imgSrc} />
          </a>
        </GrayContainer>
        <div>
          <ImageSource question={question} imgSrc={imgSrc} />
        </div>
        {question.platform.id === "metaculus" ? (
          <>
            <div className="justify-self-stretch">
              <MetaculusEmbed question={question} />
            </div>
            <div>
              <MetaculusSource question={question} />
            </div>
          </>
        ) : null}
      </div>
    );
  }

  return (
    <div className="flex flex-col space-y-2">
      <GrayContainer title="Resizable preview">
        <Resizable
          minWidth={320}
          bounds="window"
          enable={{ right: true, left: true }}
        >
          <div ref={containerRef}>
            <QuestionCard
              container={(children) => (
                <div className="bg-white px-4 py-3">{children}</div>
              )}
              question={question}
              showTimeStamp={true}
              showExpandButton={false}
              expandFooterToFullWidth={true}
            />
          </div>
        </Resizable>
      </GrayContainer>
      <Button onClick={onCaptureButtonClick} size="small">
        {mainButtonText}
      </Button>
    </div>
  );
};

// Note: https://stackoverflow.com/questions/66016033/can-no-longer-upload-images-to-imgur-from-localhost
// Use: http://imgurtester:3000/embed for testing.



---
File: /src/web/questions/components/IndicatorsTable.tsx
---

import { FC, PropsWithChildren } from "react";

import { QuestionFragment } from "../../fragments.generated";
import {
  formatIndicatorValue,
  qualityIndicatorLabels,
  UsedIndicatorName,
} from "./QuestionCard/QuestionFooter";
import { Stars } from "./Stars";

interface Props {
  question: QuestionFragment;
}

const TableRow: FC<PropsWithChildren<{ title: string }>> = ({
  title,
  children,
}) => (
  <tr className="border-b">
    <th
      scope="row"
      className="whitespace-nowrap px-6 py-4 font-medium text-gray-900"
    >
      {title}
    </th>
    <td className="px-6 py-4">{children}</td>
  </tr>
);

export const IndicatorsTable: React.FC<Props> = ({ question }) => (
  <div className="relative overflow-x-auto shadow-md sm:rounded-lg">
    <table className="w-full text-left text-sm text-gray-500">
      <thead className="bg-gray-100 text-xs uppercase text-gray-700">
        <tr>
          <th scope="col" className="px-6 py-3">
            Indicator
          </th>
          <th scope="col" className="px-6 py-3">
            Value
          </th>
        </tr>
      </thead>
      <tbody>
        <TableRow title="Stars">
          <Stars num={question.qualityIndicators.stars} />
        </TableRow>
        <TableRow title="Platform">{question.platform.label}</TableRow>
        {question.qualityIndicators.numForecasts ? (
          <TableRow title="Number of forecasts">
            {question.qualityIndicators.numForecasts}
          </TableRow>
        ) : null}
        {Object.keys(question.qualityIndicators)
          .filter(
            (indicator): indicator is UsedIndicatorName =>
              (question.qualityIndicators as any)[indicator] != null &&
              indicator in qualityIndicatorLabels
          )
          .map((indicator) => {
            return (
              <TableRow
                title={qualityIndicatorLabels[indicator]}
                key={indicator}
              >
                {formatIndicatorValue(
                  Number(question.qualityIndicators[indicator]), // must be non-null due to former check
                  indicator,
                  question.platform.id
                )}
              </TableRow>
            );
          })}
      </tbody>
    </table>
  </div>
);



---
File: /src/web/questions/components/PlatformLink.tsx
---

import { FC } from "react";

import { BoxedLink } from "../../common/BoxedLink";
import { QuestionFragment } from "../../fragments.generated";

export const PlatformLink: FC<{ question: QuestionFragment }> = ({
  question,
}) => <BoxedLink url={question.url}>{question.platform.label}</BoxedLink>;



---
File: /src/web/questions/components/QuestionChartOrVisualization.tsx
---

import { FC } from "react";

import { QuestionWithHistoryFragment } from "../../fragments.generated";
import { HistoryChart } from "./HistoryChart";

export const QuestionChartOrVisualization: FC<{
  question: QuestionWithHistoryFragment;
}> = ({ question }) => {
  if (question.platform.id === "guesstimate" && question.visualization) {
    return (
      <a className="no-underline" href={question.url} target="_blank">
        <img
          className="rounded-sm"
          src={question.visualization}
          alt="Guesstimate Screenshot"
        />
      </a>
    );
  }

  if (question.options.length > 0) {
    return <HistoryChart question={question} />;
  }

  return null; /* Don't display chart if there are no options, for now. */
};



---
File: /src/web/questions/components/QuestionInfoRow.tsx
---

import { QuestionFragment } from "../../fragments.generated";
import { PlatformLink } from "./PlatformLink";
import { QuestionOptions } from "./QuestionOptions";
import { Stars } from "./Stars";

type Props = {
  question: QuestionFragment;
};

export const QuestionInfoRow: React.FC<Props> = ({ question }) => (
  <div className="flex items-center gap-2">
    <PlatformLink question={question} />
    <Stars num={question.qualityIndicators.stars} />
    <QuestionOptions
      question={{ ...question }}
      maxNumOptions={1}
      forcePrimaryMode={true}
    />
  </div>
);



---
File: /src/web/questions/components/QuestionOptions.tsx
---

import {
  FullQuestionOption,
  isFullQuestionOption,
} from "../../../common/types";
import { QuestionFragment } from "../../fragments.generated";
import { isQuestionBinary } from "../../utils";
import { formatProbability } from "../utils";

const textColor = (probability: number) => {
  if (probability < 0.03) {
    return "text-red-600";
  } else if (probability < 0.1) {
    return "text-red-600 opacity-80";
  } else if (probability < 0.2) {
    return "text-red-600 opacity-80";
  } else if (probability < 0.3) {
    return "text-red-600 opacity-70";
  } else if (probability < 0.4) {
    return "text-red-600 opacity-70";
  } else if (probability < 0.5) {
    return "text-gray-500";
  } else if (probability < 0.6) {
    return "text-gray-500";
  } else if (probability < 0.7) {
    return "text-green-600 opacity-70";
  } else if (probability < 0.8) {
    return "text-green-600 opacity-70";
  } else if (probability < 0.9) {
    return "text-green-600 opacity-80";
  } else if (probability < 0.97) {
    return "text-green-600 opacity-80";
  } else {
    return "text-green-600";
  }
};

const primaryForecastColor = (probability: number) => {
  if (probability < 0.03) {
    return "bg-red-600";
  } else if (probability < 0.1) {
    return "bg-red-600 opacity-80";
  } else if (probability < 0.2) {
    return "bg-red-600 opacity-70";
  } else if (probability < 0.3) {
    return "bg-red-600 opacity-60";
  } else if (probability < 0.4) {
    return "bg-red-600 opacity-50";
  } else if (probability < 0.5) {
    return "bg-gray-500";
  } else if (probability < 0.6) {
    return "bg-gray-500";
  } else if (probability < 0.7) {
    return "bg-green-600 opacity-50";
  } else if (probability < 0.8) {
    return "bg-green-600 opacity-60";
  } else if (probability < 0.9) {
    return "bg-green-600 opacity-70";
  } else if (probability < 0.97) {
    return "bg-green-600 opacity-80";
  } else {
    return "bg-green-600";
  }
};

const chooseColor = (probability: number) => {
  if (probability < 0.1) {
    return "bg-blue-50 text-blue-500";
  } else if (probability < 0.3) {
    return "bg-blue-100 text-blue-600";
  } else if (probability < 0.7) {
    return "bg-blue-200 text-blue-700";
  } else {
    return "bg-blue-300 text-blue-800";
  }
};

const primaryEstimateAsText = (probability: number) => {
  if (probability < 0.03) {
    return "Exceptionally unlikely";
  } else if (probability < 0.1) {
    return "Very unlikely";
  } else if (probability < 0.4) {
    return "Unlikely";
  } else if (probability < 0.6) {
    return "About Even";
  } else if (probability < 0.9) {
    return "Likely";
  } else if (probability < 0.97) {
    return "Very likely";
  } else {
    return "Virtually certain";
  }
};

type OptionProps = {
  option: FullQuestionOption;
  mode: "primary" | "normal"; // affects font size and colors
  textMode: "name" | "probability"; // whether to output option name or probability estimate as text
};

const OptionRow: React.FC<OptionProps> = ({ option, mode, textMode }) => {
  return (
    <div className="flex items-center space-x-2">
      <div
        className={`flex-none rounded-md text-center ${
          mode === "primary"
            ? "text-normal px-2 py-0.5 text-sm font-bold text-white md:text-lg"
            : "w-14 py-0.5 text-sm"
        } ${
          mode === "primary"
            ? primaryForecastColor(option.probability)
            : chooseColor(option.probability)
        }`}
      >
        {formatProbability(option.probability)}
      </div>
      <div
        className={`leading-snug ${
          mode === "primary" ? "text-normal text-sm md:text-lg" : "text-sm"
        } ${
          mode === "primary" ? textColor(option.probability) : "text-gray-700"
        }`}
      >
        {textMode === "name"
          ? option.name
          : primaryEstimateAsText(option.probability)}
      </div>
    </div>
  );
};

export const QuestionOptions: React.FC<{
  question: QuestionFragment;
  maxNumOptions: number;
  forcePrimaryMode?: boolean;
}> = ({ question, maxNumOptions, forcePrimaryMode = false }) => {
  const isBinary = isQuestionBinary(question);

  if (isBinary) {
    const yesOption = question.options.find((o) => o.name === "Yes");
    if (!yesOption) {
      return null; // shouldn't happen
    }
    if (!isFullQuestionOption(yesOption)) {
      return null; // missing data
    }

    return (
      <OptionRow option={yesOption} mode="primary" textMode="probability" />
    );
  } else {
    const optionsSorted = question.options
      .filter(isFullQuestionOption)
      .sort((a, b) => b.probability - a.probability);

    const optionsMaxN = optionsSorted.slice(0, maxNumOptions); // display max 5 options.

    return (
      <div className="space-y-2">
        {optionsMaxN.map((option, i) => (
          <OptionRow
            key={i}
            option={option}
            mode={forcePrimaryMode ? "primary" : "normal"}
            textMode="name"
          />
        ))}
      </div>
    );
  }
};



---
File: /src/web/questions/components/QuestionTitle.tsx
---

import { QuestionFragment } from "../../fragments.generated";
import { getBasePath } from "../../utils";

type Props = {
  question: QuestionFragment;
  linkToMetaforecast?: boolean;
};

export const QuestionTitle: React.FC<Props> = ({
  question,
  linkToMetaforecast,
}) => (
  <h1 className="text-lg sm:text-3xl">
    <a
      className="text-black no-underline hover:text-gray-700"
      href={
        linkToMetaforecast
          ? getBasePath() + `/questions/${question.id}`
          : question.url
      }
      target="_blank"
    >
      {question.title}
    </a>
  </h1>
);



---
File: /src/web/questions/components/Stars.tsx
---

// Database-like functions
export function getstars(numstars: number) {
  let stars = "★★☆☆☆";
  switch (numstars) {
    case 0:
      stars = "☆☆☆☆☆";
      break;
    case 1:
      stars = "★☆☆☆☆";
      break;
    case 2:
      stars = "★★☆☆☆";
      break;
    case 3:
      stars = "★★★☆☆";
      break;
    case 4:
      stars = "★★★★☆";
      break;
    case 5:
      stars = "★★★★★";
      break;
    default:
      stars = "★★☆☆☆";
  }
  return stars;
}

function getStarsColor(numstars: number) {
  let color = "text-yellow-400";
  switch (numstars) {
    case 0:
      color = "text-red-400";
      break;
    case 1:
      color = "text-red-400";
      break;
    case 2:
      color = "text-orange-400";
      break;
    case 3:
      color = "text-yellow-400";
      break;
    case 4:
      color = "text-green-400";
      break;
    case 5:
      color = "text-blue-400";
      break;
    default:
      color = "text-yellow-400";
  }
  return color;
}

export const Stars: React.FC<{ num: number }> = ({ num }) => {
  return (
    <div className={getStarsColor(num) + " text-xs md:text-lg"}>
      {getstars(num)}
    </div>
  );
};



---
File: /src/web/questions/utils.ts
---

export const formatProbability = (probability: number) => {
  let percentage = probability * 100;
  let percentageCapped =
    percentage < 1
      ? "< 1%"
      : percentage > 99
        ? "> 99%"
        : percentage.toFixed(0) + "%";
  return percentageCapped;
};



---
File: /src/web/worker/searchWithElastic.ts
---

import {
  Client as ElasticClient,
  estypes as ElasticTypes,
} from "@elastic/elasticsearch";

import { ElasticQuestion } from "../../backend/utils/elastic";

let _CACHED_CLIENT: ElasticClient | null = null;
function getClient() {
  if (!_CACHED_CLIENT) {
    _CACHED_CLIENT = new ElasticClient({
      node: process.env["ELASTIC_HOST"]!,
      auth: {
        username: process.env["ELASTIC_USER"]!,
        password: process.env["ELASTIC_PASSWORD"]!,
      },
    });
  }
  return _CACHED_CLIENT;
}

const INDEX_NAME = process.env["ELASTIC_INDEX"]!;

interface SearchOpts {
  queryString: string;
  hitsPerPage?: number;
  starsThreshold?: number;
  filterByPlatforms?: string[];
  forecastsThreshold?: number;
}

function buildFilter({
  starsThreshold,
  filterByPlatforms,
  forecastsThreshold,
}: Pick<
  SearchOpts,
  "starsThreshold" | "filterByPlatforms" | "forecastsThreshold"
>) {
  const filters: ElasticTypes.QueryDslQueryContainer[] = [];

  if (starsThreshold) {
    filters.push({
      range: {
        "qualityindicators.stars": {
          gte: starsThreshold,
        },
      },
    });
  }

  if (filterByPlatforms) {
    filters.push({
      terms: {
        platform: filterByPlatforms,
      },
    });
  }

  if (forecastsThreshold && forecastsThreshold > 0) {
    filters.push({
      range: {
        "qualityindicators.numforecasts": {
          gte: forecastsThreshold,
        },
      },
    });
  }

  return filters;
}

function noExactMatch(
  queryString: string,
  result: ElasticTypes.SearchHit<ElasticQuestion>
) {
  queryString = queryString.toLowerCase();

  const title = result._source?.title.toLowerCase();
  const description = result._source?.description.toLowerCase();
  const optionsstringforsearch = (
    result._source?.optionsstringforsearch || ""
  ).toLowerCase();

  return !(
    title?.includes(queryString) ||
    description?.includes(queryString) ||
    optionsstringforsearch.includes(queryString)
  );
}

// only query string
export async function searchWithElastic({
  queryString,
  hitsPerPage = 5,
  starsThreshold,
  filterByPlatforms,
  forecastsThreshold,
}: SearchOpts): Promise<ElasticTypes.SearchHit<ElasticQuestion>[]> {
  const response = await getClient().search<ElasticQuestion>({
    index: INDEX_NAME,
    sort: [{ "qualityindicators.stars": "desc" }, "_score"],
    query: {
      bool: {
        must: [
          {
            multi_match: {
              query: queryString,
              fields: [
                "title^5",
                "description",
                "optionsstringforsearch",
                "platform",
              ],
            },
          },
        ],
        filter: buildFilter({
          starsThreshold,
          forecastsThreshold,
          filterByPlatforms,
        }),
      },
    },
    size: hitsPerPage,
  });

  let results = response.hits.hits;

  let recursionError = ["metaforecast", "metaforecasts", "metaforecasting"];
  if (
    (!results || results.length === 0) &&
    !recursionError.includes(queryString.toLowerCase())
  ) {
    results = [
      {
        _id: "not-found",
        _index: "FAKE",
        _source: {
          id: "not-found",
          objectID: "not-found",
          title: "No search results match your query",
          url: "https://metaforecast.org",
          platform: "metaforecast",
          platformLabel: "metaforecast",
          description:
            "Maybe try a broader query, e.g., reduce the number of 'stars' by clicking in 'Advanced options'?",
          options: [
            {
              name: "Yes",
              probability: 0.995,
              type: "PROBABILITY",
            },
            {
              name: "No",
              probability: 0.005,
              type: "PROBABILITY",
            },
          ],
          fetched: new Date().toISOString(),
          firstSeen: new Date().toISOString(),
          qualityindicators: {
            numforecasts: 1,
            numforecasters: 1,
            stars: 5,
          },
          extra: {},
        },
      },
    ];
  } else if (recursionError.includes(queryString.toLowerCase())) {
    results = [
      {
        _id: "recursion-error",
        _index: "FAKE",
        _source: {
          id: "recursion-error",
          objectID: "recursion-error",
          title: `Did you mean: ${queryString}?`,
          url: "https://metaforecast.org/recursion?bypassEasterEgg=true",
          platform: "metaforecast",
          platformLabel: "metaforecast",
          description:
            "Fatal error: Too much recursion. Click to proceed anyways",
          fetched: new Date().toISOString(),
          firstSeen: new Date().toISOString(),
          options: [
            {
              name: "Yes",
              probability: 0.995,
              type: "PROBABILITY",
            },
            {
              name: "No",
              probability: 0.005,
              type: "PROBABILITY",
            },
          ],
          qualityindicators: {
            numforecasts: 1,
            numforecasters: 1,
            stars: 5,
          },
          extra: {},
        },
      },
      ...results,
    ];
  } else if (
    queryString &&
    queryString.split(" ").length == 1 &&
    noExactMatch(queryString, results[0])
  ) {
    results.unshift({
      _id: "not-found-2",
      _index: "FAKE",
      _source: {
        id: "not-found-2",
        objectID: "not-found-2",
        title: "No search results appear to match your query",
        url: "https://metaforecast.org",
        platform: "metaforecast",
        platformLabel: "metaforecast",
        description:
          "Maybe try a broader query? Maybe try a broader query, e.g., reduce the number of 'stars' by clicking in 'Advanced options'? That said, we could be wrong.",
        options: [
          {
            name: "Yes",
            probability: 0.65,
            type: "PROBABILITY",
          },
          {
            name: "No",
            probability: 0.35,
            type: "PROBABILITY",
          },
        ],
        fetched: new Date().toISOString(),
        firstSeen: new Date().toISOString(),
        qualityindicators: {
          numforecasts: 1,
          numforecasters: 1,
          stars: 1,
        },
        extra: {},
      },
    });
  }

  return results;
}
// Examples:
// searchWithElastic({queryString: "Life"}, () => null)
// searchWithElastic({queryString: "Life", forecastsThreshold: 100}, () => null)
// searchWithElastic({queryString: "Life", forecastsThreshold: 100, starsThreshold: 4}, () => null)
// searchWithElastic({queryString: "Life", forecastsThreshold: 100, starsThreshold: 3, filterByPlatforms: ["Metaculus", "PolyMarket"]}, () => null)



---
File: /src/web/worker/uploadToImgur.ts
---

import axios, { AxiosRequestConfig } from "axios";

type AxiosRequestConfigWithAnyHeaders = Omit<AxiosRequestConfig, "headers"> & {
  headers?: any;
  // See: <https://github.com/axios/axios/issues/4193>
};

export async function uploadToImgur(dataURL: string): Promise<string> {
  const request: AxiosRequestConfigWithAnyHeaders = {
    method: "post",
    url: "https://api.imgur.com/3/image",
    headers: {
      Authorization: `Bearer ${process.env["IMGUR_BEARER"]}`,
    },
    data: {
      type: "base64",
      image: dataURL.split(",")[1],
    },
  };

  let url = "https://i.imgur.com/qcThRRz.gif"; // Error image
  try {
    const response = await axios(request).then((response) => response.data);
    url = `https://i.imgur.com/${response.data.id}.png`;
  } catch (error) {
    console.log("error", error);
  }

  return url;
}



---
File: /src/web/urql.ts
---

import customScalarsExchange from "@atmina/urql-custom-scalars-exchange";
import { createClient } from "@urql/core";
import { SSRExchange } from "@urql/next";
import { registerUrql } from "@urql/next/rsc";
import { cacheExchange, fetchExchange } from "urql";

import schema from "../graphql/introspection.json";
import { getBasePath } from "./utils";

export const graphqlEndpoint = `${getBasePath()}/api/graphql`;

const scalarsExchange = customScalarsExchange({
  // Types don't match for some reason.
  // Related:
  // - https://github.com/apollographql/apollo-tooling/issues/1491
  // - https://spectrum.chat/urql/help/schema-property-kind-is-missing-in-type~29c8f416-068c-485a-adf1-935686b99d05
  schema: schema as any,
  scalars: {
    /* not compatible with next.js serialization limitations, unfortunately */
    // Date(value: number) {
    //   return new Date(value * 1000);
    // },
  },
});

export function getUrqlClientOptions(ssr: SSRExchange | undefined) {
  return {
    url: graphqlEndpoint,
    exchanges: [
      scalarsExchange,
      cacheExchange,
      ...(ssr ? [ssr] : []),
      fetchExchange,
    ],
  };
}

export function getUrqlRscClient() {
  // this is overly complicated, we could just call `React.cache` here as `registerUrql` does
  const { getClient } = registerUrql(() =>
    createClient(getUrqlClientOptions(undefined))
  );

  return getClient();
}



---
File: /src/web/utils.ts
---

import { QuestionFragment } from "./fragments.generated";

export const getBasePath = () => {
  if (process.env["NEXT_PUBLIC_VERCEL_URL"]) {
    return `https://metaforecast.org`; //`https://${process.env.NEXT_PUBLIC_VERCEL_URL}`;
  }

  // can be used for local development if you prefer non-default port
  if (process.env["NEXT_PUBLIC_SITE_URL"]) {
    return process.env["NEXT_PUBLIC_SITE_URL"];
  }

  return "http://localhost:3002";
};

export const cleanText = (text: string): string => {
  // TODO - move to GraphQL:
  // { description(clean: true, truncate: 250) }
  let textString = !!text ? text : "";
  textString = textString
    .replaceAll("] (", "](")
    .replaceAll(") )", "))")
    .replaceAll("( [", "([")
    .replaceAll(") ,", "),")
    .replaceAll("==", "") // Denotes a title in markdown
    .replaceAll(/^#+\s+/gm, "")
    .replaceAll(/^Background\n/gm, "")
    .replaceAll(/^Context\n/gm, "")
    .replaceAll("--- \n", "- ")
    .replaceAll(/\[(.*?)\]\(.*?\)/g, "$1");
  textString = textString.slice(0, 1) == "=" ? textString.slice(1) : textString;

  return textString;
};

export const isQuestionBinary = (question: QuestionFragment): boolean => {
  const { options } = question;
  return (
    options.length === 2 &&
    ((options[0].name === "Yes" && options[1].name === "No") ||
      (options[0].name === "No" && options[1].name === "Yes"))
  );
};



---
File: /src/_middleware.ts
---

import { NextURL } from "next/dist/server/web/next-url";
import { NextRequest, NextResponse } from "next/server";

export async function middleware(req: NextRequest) {
  const { pathname, searchParams } = req.nextUrl;

  if (pathname === "/dashboards") {
    const dashboardId = searchParams.get("dashboardId");
    if (dashboardId) {
      return NextResponse.redirect(
        new URL(`/dashboards/view/${dashboardId}`, req.url)
      );
    }
  } else if (pathname === "/capture") {
    return NextResponse.redirect(new URL("/", req.url));
  } else if (pathname === "/secretDashboard") {
    const dashboardId = searchParams.get("dashboardId");
    if (dashboardId) {
      const url = new URL(`/dashboards/embed/${dashboardId}`, req.url);
      const numCols = searchParams.get("numCols");
      if (numCols) {
        url.searchParams.set("numCols", numCols);
      }
      return NextResponse.redirect(url);
    } else {
      return NextResponse.rewrite(new NextURL("/404", req.url));
    }
  }

  return NextResponse.next();
}



---
File: /src/Global.d.ts
---

// Workaround related to: https://github.com/vercel/next.js/issues/29788
// https://github.com/vercel/next.js/issues/29788#issuecomment-1000595524
declare type StaticImageData = {
  src: string;
  height: number;
  width: number;
  placeholder?: string;
};



---
File: /src/utils.ts
---

export function shuffleArray<T>(array: T[]): T[] {
  // See: https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

export function average(array: number[]) {
  return array.reduce((a, b) => a + b, 0) / array.length;
}

export function sum(arr: number[]) {
  return arr.reduce((a, b) => a + b, 0);
}



---
File: /next-env.d.ts
---

/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.



---
File: /postcss.config.js
---

module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};



---
File: /tailwind.config.js
---

module.exports = {
  content: ["./src/**/*.tsx"],
  darkMode: "media", // or 'media' or 'class'
  theme: {
    extend: {
      backgroundImage: {
        quri: "url('/icons/logo.svg')",
      },
      maxWidth: {
        160: "160px",
      },
    },
  },
  variants: {
    extend: {},
    margin: ["responsive", "hover"],
  },
  plugins: [require("@tailwindcss/forms"), require("@tailwindcss/typography")],
};

